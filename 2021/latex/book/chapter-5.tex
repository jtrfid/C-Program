%%%%%%%%%%%%%%%%%%%%% chapter.tex %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% sample chapter
%
% Use this file as a template for your own input.
%
%%%%%%%%%%%%%%%%%%%%%%%% Springer-Verlag %%%%%%%%%%%%%%%%%%%%%%%%%%
%\motto{Use the template \emph{chapter.tex} to style the various elements of your chapter content.}
\chapter{第5次机试练习: 继续练习基本输入输出语句，分支与循环，简单数组应用}

\section{最小差值}
给定n个数，请找出其中相差（差的绝对值）最小的两个数，输出它们的差值的绝对值。

输入格式

输入第一行包含一个整数n。

第二行包含n个正整数，相邻整数之间使用一个空格分隔。

输出格式

输出一个整数，表示答案。

样例输入

5

1 5 4 8 20

样例输出

1

样例说明

相差最小的两个数是5和4，它们之间的差值是1。

样例输入

5

9 3 6 1 3

样例输出

0

样例说明

有两个相同的数3，它们之间的差值是0.

数据规模和约定

对于所有评测用例，$2\le n\le1000$，每个给定的整数都是不超过10000的正整数。

\begin{lstlisting}
#include <stdio.h>
#include <math.h>
#define N 10000 // 估计数组num的最大长度 
int main()
{
	int i,j,n,num[N],smallest,temp; 
	scanf("%d",&n);
	// 输入数组各元素
	for(i=0;i<n;i++) // 实际数组的最大长度n, 下标由0到(n-1)
	{
		scanf("%d",&num[i]);
	}
	// 初始的最小值就是前两个数的差值, 注意初始化值必须是实际存在的值，而不能想当然给值。
	smallest=(int)fabs(num[0]-num[1]); // 整数绝对值函数int abs(int x)在低版本编译器中有问题, 此处用双精度绝对值函数代替, 其结果转换为整数。  
	
	// 前后两项比较
	for(i=0;i<=n-2;i++) // 循环变量i用于访问数组元素, 注意数组边界问题
	{
		for(j=i+1;j<n;j++)
		{
			temp=(int)fabs(num[i]-num[j]);
			if(smallest>temp) smallest=temp;
		}
	}
	printf("%d\n",smallest);
	return 0;
} 
\end{lstlisting}

\begin{note}[整数求绝对值函数]
	\lstinline|int abs(int x);| 在有些低版本编译器中，\lstinline|math.h|头文件无此函数原型说明，可用\lstinline|double fabs(double x);|代替。见本例。
\end{note}

\section{PM2.5}
给出一组PM2.5数据，按以下分级标准统计各级天气的天数，并计算出PM2.5平均值。
PM2.5分级标准为:\\
一级优(0<=PM2.5<=50)\\
二级良(1<=PM2.5<=100)\\
三级轻度污染(101<=PM2.5<=150)\\
四级中度污染(151<=PM2.5<=200)\\
五级重度污染(201<=PM2.5<=300)\\
六级严重污染(PM2.5>300)\\

输入说明
	
输入分为两行，

第一行是一个整数n表示天数（1<n<=100）；

第二行为n个非负整数Pi（0<=Pi<=1000），表示每天的PM2.5值，整数之间用空格分隔。

输出说明
	
输出两行数据，

第一行为PM2.5平均值，结果保留2位小数；

第二行依次输出一级优，二级良，三级轻度污染，四级中度污染，五级重度污染，六级严重污染的天数。

输入样例
	
10

50 100 120 80 200 350 400 220 180 165

输出样例	

186.50

1 2 1 3 1 2

\begin{lstlisting}
#include <stdio.h>

int main()
{
	// 用数组变量day存储数据，避免设置6个变量存储。
	int i =0,n,pm25,day[6] = {0,0,0,0,0,0},sum = 0;
	scanf("%d",&n);
	while(i < n) 
	{
		scanf("%d",&pm25);
		sum += pm25;
		if(pm25 >= 0 && pm25 <= 50 ) day[0]++;
		else if(pm25 >= 51 && pm25 <= 100 ) day[1]++;
		else if(pm25 >= 101 && pm25 <= 150 ) day[2]++;
		else if(pm25 >= 151 && pm25 <= 200 ) day[3]++;
		else if(pm25 >= 201 && pm25 <= 300 ) day[4]++;
		else day[5]++;
		i++;
	} 
	printf("%.2f\n",(float)sum/n);
	for(i = 0; i < 6; i++)  // 视作一条语句, 省略{ }
		if(i == 5) printf("%d\n",day[i]);
		else  printf("%d ",day[i]);
	
	return 0;
} 
\end{lstlisting}

\begin{note}[要点]
	\lstinline|if() { } else if() { } else { }|的用法, 循环语句的\{ \}.
	
	体会数组变量day的使用, 避免变量过多，难于管理的麻烦。
\end{note}

\section{折点计数}	
给定n个整数表示一个商店连续n天的销售量。如果某天之前销售量在增长，而后一天销售量减少，则称这一天为折点，反过来如果之前销售量减少而后一天销售量增长，也称这一天为折点，其他的天都不是折点。如图所示，第3天和第6天是折点。

\includegraphics*[scale=0.7]{points}

给定n个整数a1, a2, \dots, an表示连续n天中每天的销售量。请计算出这些天总共有多少个折点。

输入说明
	
输入的第一行包含一个整数n。

第二行包含n个整数，用空格分隔，分别表示a1, a2, \dots, an。

$3\le n\le 100$，每天的销售量是不超过1000的非负整数。为了减少歧义，输入数据保证：在这n天中相邻两天的销售量总是不同的，即$ai-1\ne ai$。

输出说明	

输出一个整数，表示折点数量。

输入样例	

7

5 4 1 2 3 6 4

输出样例
	
2

\begin{lstlisting}
#include <stdio.h>
// 解法一, 使用标志变量up, 判断是否后一数据大于前一数据.
int main()
{
    // 估计数组a的实际长度为100, 实际长度是n(待输入的值)
	int i = 0, points = 0, n = 7, a[100] = {5,4,1,2,3,6,4}; // 把样例数据作为初始化，方便调试
	int up; // 标志变量 
	
	// 有了初始化数据，这些输入语句在调试时就可注释掉，达到快速调试程序逻辑的目的。
	scanf("%d",&n); // 输入数组a的实际长度
	// 输入各元数值
	for(i = 0; i < n; i++) scanf("%d",&a[i]);
	
	// 标志变量up的初始值必须是真实存在的值，不要想当然。
	up = a[1] > a[0] ? 1 : -1; // 如果a[1] > a[0]成立, up=1,否则up=-1
	for(i = 2; i < n; i++)
	{
		if((a[i] > a[i-1] && up < 0) || (a[i] < a[i-1] && up > 0))
			points++;
		up = a[i] > a[i-1] ? 1 : -1;
	}
	
	printf("%d\n",points);
	return 0;
} 

// 解法二, 通过判断a[i]前后相邻两数据, 确定是否折点. 
int main()
{
	// 估计数组a的实际长度为100, 实际长度是n(待输入的值)
	int i = 0, points = 0, n = 7, a[100] = {5,4,1,2,3,6,4}; // 把样例数据作为初始化，方便调试
	scanf("%d",&n);
	for(i=0;i<n;i++) scanf("%d",&a[i]);
	
	for(i=1;i<n-1;i++) // 注意数组边界，不要越界。 
	{
		if((a[i]<a[i-1] && a[i]<a[i+1]) || (a[i]>a[i-1] && a[i]>a[i+1]))
			points++;
	}
	printf("%d\n",points);
	return 0;
}
\end{lstlisting}

\begin{note}[要点]
	善用标志变量, 标志变量的初始值必须是真实存在的值，不要想当然。
	
	样例数据作为初始化数据，调试时注释掉输入语句，便于进行快速调试程序。
\end{note}

\section{寻找最大整数}
从键盘输入四个整数，找出其中的最大值并将其输出。

输入说明

输入4个整数，用空格分隔

输出说明

输出值最大的一个整数

输入样例

25 99 -46 0

输出样例

99

\begin{lstlisting}
#include <stdio.h>
// 不用存储整数序列, 采用一条循环语句，合并输入和计算，减少出错概率。 
int main() 
{
	int i, num, max;
	// 输入, 并计算 
	for(i = 0; i < 4; i++) 
	{ 
		if (i==0) scanf("%d",&max); // 假定第一个数就是最大的数 
		else
		{
			scanf("%d",&num);
			if(num > max) max=num; 
		} 
	} 
	printf("%d\n",max);
	return 0;
} 

int main1() // 另解, 存储整数序列
{
	int i, num[4], max;
	// 输入 
	for(i = 0; i < 4; i++) 
		scanf("%d",&num[i]);
	// 假定的最大值必须是实际存在的，不要想当然是0,9999,等等。
	max = num[0]; 
	for(i = 0; i < 4; i++)  
		if(max < num[i]) max = num[i];
	
	printf("%d\n",max);
	return 0;
} 
\end{lstlisting}

\begin{note}[要点]
	题目虽然简单，你能体会哪种解法更好? 特别注意假定变量的值必须是实际存在的数。
\end{note}

\section{ISBN号码}
每一本正式出版的图书都有一个ISBN号码与之对应，ISBN码包括9位数字、1位识别码和3位分隔符，其规定格式如"x-xxx-xxxxx-x"，
其中符号“-”是分隔符（键盘上的减号），最后一位是识别码，例如0-670-82162-4就是一个标准的ISBN码。

ISBN码的首位数字表示书籍的出版语言，例如0代表英语；

第一个分隔符“-”之后的三位数字代表出版社，例如670代表维京出版社；

第二个分隔之后的五位数字代表该书在出版社的编号；

最后一位为识别码。识别码的计算方法如下：

首位数字乘以1加上次位数字乘以2……以此类推，用所得的结果mod 11，所得的余数即为识别码，如果余数为10，则识别码为大写字母X。
例如ISBN号码0-670-82162-4中的识别码4是这样得到的：
对067082162这9个数字，从左至右，分别乘以1，2，\dots，9，再求和，即$0\times 1+6\times 2+\dots +2\times 9=158$，然后取158 mod 11的结果4作为识别码。

编写程序判断输入的ISBN号码中识别码是否正确，如果正确，则仅输出``Right"; 如果错误，则输出正确的ISBN号码。

输入说明	

输入只有一行，是一个字符序列，表示一本书的ISBN号码(保证输入符合ISBN号码的格式要求)。

输出说明	

输出一行，假如输入的ISBN号码的识别码正确，那么输出``Right"，否则，按照规定的格式，输出正确的ISBN号码(包括分隔符``-")。

输入样例	

样例输入1

0-670-82162-4

样例输入2

0-670-82162-0

输出样例	

样例输出1

Right

样例输出2

0-670-82162-4

\begin{lstlisting}
#include <stdio.h>
int main()
{
	// 按题意, 存储ISBN需要13个字符, 再加上字符串结束字符'\0'.
	// 样例数据作为初始化，方便调试
	char ISBN[14] = "0-670-82162-4";  // ISBN[13]='\0'
	//char ISBN[14] = "0-670-82162-0";  
	int i,j,sum=0,r; // r=sum % 11 
	
	// 调试时，注释输入语句 
	// 末尾自动添加'\0'.
	scanf("%s",ISBN);  // 或 gets(ISBN);
	
	// 对识别码之前的数字求和, 注意边界.
	for(i = 0,j = 1; i < 11; i++)
	{
		if (ISBN[i]=='-') continue;
		sum += (ISBN[i]-'0')*j;   // 整数与单个数字字符的关系：9 = '9' -'0' 
		j++;
	}   
	
	r=sum%11;
	
	// 特别处理识别码 ISBN[12]
	if (r==10)
	{
		if(ISBN[12]=='X') printf("Right\n");
		else 
		{
			ISBN[12]='X';
			printf("%s\n",ISBN); // 或 puts(ISBN);
		}
	}
	else
	{
		// 数字转字符 r+'0'
		if(ISBN[12]== r +'0') printf("Right\n");
		else 
		{
			ISBN[12]= r +'0';
			printf("%s\n",ISBN); // 或 puts(ISBN);
		}
	} 
	
	return 0;
} 
\end{lstlisting}

\begin{note}[要点]
	\begin{enumerate}
		\item 仔细审题, 考虑输入的识别码, 可能是'X'的情况.
		\item 定义字符数组表示字符串时，且记给\lstinline|'\0'|留一个字符的位置, 表示字符串的结尾。
		\item \lstinline|ASCII编码(整数)=字符-'0';|
		\item \lstinline|字符=ASCII编码(整数)+'0';|
		\item 整数可以表示字符的ASCII编码(整数), 整数和字符类型可以``混用", 详见课件。
		\begin{lstlisting}
		int a; char c='A';
		a = c+1; // c当作整数运算
		printf("%d %c %d %c\n",a,a,c,c); //66 B 65 A 
		\end{lstlisting}
	\end{enumerate}
\end{note}

