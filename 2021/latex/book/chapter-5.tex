%%%%%%%%%%%%%%%%%%%%% chapter.tex %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% sample chapter
%
% Use this file as a template for your own input.
%
%%%%%%%%%%%%%%%%%%%%%%%% Springer-Verlag %%%%%%%%%%%%%%%%%%%%%%%%%%
%\motto{Use the template \emph{chapter.tex} to style the various elements of your chapter content.}
\chapter{第5次机试练习: 继续练习基本输入输出语句，分支与循环，简单数组应用}

\section{最小差值}
给定n个数，请找出其中相差（差的绝对值）最小的两个数，输出它们的差值的绝对值。

输入格式

输入第一行包含一个整数n。

第二行包含n个正整数，相邻整数之间使用一个空格分隔。

输出格式

输出一个整数，表示答案。

样例输入

5

1 5 4 8 20

样例输出

1

样例说明

相差最小的两个数是5和4，它们之间的差值是1。

样例输入

5

9 3 6 1 3

样例输出

0

样例说明

有两个相同的数3，它们之间的差值是0.

数据规模和约定

对于所有评测用例，$2\le n\le1000$，每个给定的整数都是不超过10000的正整数。

\begin{lstlisting}
#include <stdio.h>
#include <math.h>
#define N 10000 // 估计数组num的最大长度 
int main()
{
	int i,j,n,num[N],smallest,temp; 
	scanf("%d",&n);
	// 输入数组各元素
	for(i=0;i<n;i++) // 实际数组的最大长度n, 下标由0到(n-1)
	{
		scanf("%d",&num[i]);
	}
	// 初始的最小值就是前两个数的差值, 注意初始化值必须是实际存在的值，而不能想当然给值。
	smallest=(int)fabs(num[0]-num[1]); // 整数绝对值函数int abs(int x)在低版本编译器中有问题, 此处用双精度绝对值函数代替, 其结果转换为整数。  
	
	// 前后两项比较
	for(i=0;i<=n-2;i++) // 循环变量i用于访问数组元素, 注意数组边界问题
	{
		for(j=i+1;j<n;j++)
		{
			temp=(int)fabs(num[i]-num[j]);
			if(smallest>temp) smallest=temp;
		}
	}
	printf("%d\n",smallest);
	return 0;
} 
\end{lstlisting}

\begin{note}[整数求绝对值函数]
	\lstinline|int abs(int x);| 在有些低版本编译器中，\lstinline|math.h|头文件无此函数原型说明，可用\lstinline|double fabs(double x);|代替。见本例。
\end{note}

\section{PM2.5}
给出一组PM2.5数据，按以下分级标准统计各级天气的天数，并计算出PM2.5平均值。
PM2.5分级标准为:\\
一级优(0<=PM2.5<=50)\\
二级良(1<=PM2.5<=100)\\
三级轻度污染(101<=PM2.5<=150)\\
四级中度污染(151<=PM2.5<=200)\\
五级重度污染(201<=PM2.5<=300)\\
六级严重污染(PM2.5>300)\\

输入说明
	
输入分为两行，

第一行是一个整数n表示天数（1<n<=100）；

第二行为n个非负整数Pi（0<=Pi<=1000），表示每天的PM2.5值，整数之间用空格分隔。

输出说明
	
输出两行数据，

第一行为PM2.5平均值，结果保留2位小数；

第二行依次输出一级优，二级良，三级轻度污染，四级中度污染，五级重度污染，六级严重污染的天数。

输入样例
	
10

50 100 120 80 200 350 400 220 180 165

输出样例	

186.50

1 2 1 3 1 2

\begin{lstlisting}
#include <stdio.h>

int main()
{
	// 用数组变量day存储数据，避免设置6个变量存储。
	int i =0,n,pm25,day[6] = {0,0,0,0,0,0},sum = 0;
	scanf("%d",&n);
	while(i < n) 
	{
		scanf("%d",&pm25);
		sum += pm25;
		if(pm25 >= 0 && pm25 <= 50 ) day[0]++;
		else if(pm25 >= 51 && pm25 <= 100 ) day[1]++;
		else if(pm25 >= 101 && pm25 <= 150 ) day[2]++;
		else if(pm25 >= 151 && pm25 <= 200 ) day[3]++;
		else if(pm25 >= 201 && pm25 <= 300 ) day[4]++;
		else day[5]++;
		i++;
	} 
	printf("%.2f\n",(float)sum/n);
	for(i = 0; i < 6; i++)  // 视作一条语句, 省略{ }
		if(i == 5) printf("%d\n",day[i]);
		else  printf("%d ",day[i]);
	
	return 0;
} 
\end{lstlisting}

\begin{note}[要点]
	\lstinline|if() { } else if() { } else { }|的用法, 循环语句的\{ \}.
	
	体会数组变量day的使用, 避免变量过多，难于管理的麻烦。
\end{note}

\section{折点计数}	
给定n个整数表示一个商店连续n天的销售量。如果某天之前销售量在增长，而后一天销售量减少，则称这一天为折点，反过来如果之前销售量减少而后一天销售量增长，也称这一天为折点，其他的天都不是折点。如图所示，第3天和第6天是折点。

\includegraphics*[scale=0.7]{points}

给定n个整数a1, a2, \dots, an表示连续n天中每天的销售量。请计算出这些天总共有多少个折点。

输入说明
	
输入的第一行包含一个整数n。

第二行包含n个整数，用空格分隔，分别表示a1, a2, \dots, an。

$3\le n\le 100$，每天的销售量是不超过1000的非负整数。为了减少歧义，输入数据保证：在这n天中相邻两天的销售量总是不同的，即$ai-1\ne ai$。

输出说明	

输出一个整数，表示折点数量。

输入样例	

7

5 4 1 2 3 6 4

输出样例
	
2

\begin{lstlisting}
#include <stdio.h>
int main()
{
    // 估计数组a的实际长度为100, 实际长度是n(待输入的值)
	int i = 0, points = 0, n = 7, a[100] = {5,4,1,2,3,6,4}; // 把样例数据作为初始化，方便了调试
	int up; // 标志变量 
	
	// 有了初始化数据，这些输入语句在调试时就可注释掉，达到快速调试程序逻辑的目的。
	scanf("%d",&n); // 输入数组a的实际长度
	// 输入各元数值
	for(i = 0; i < n; i++) scanf("%d",&a[i]);
	
	// 标志变量up的初始值必须是真实存在的值，不要想当然。
	up = a[1] > a[0] ? 1 : -1; // 如果a[1] > a[0]成立, up=1,否则up=-1
	for(i = 2; i < n; i++)
	{
		if((a[i] > a[i-1] && up < 0) || (a[i] < a[i-1] && up > 0))
			points++;
		up = a[i] > a[i-1] ? 1 : -1;
	}
	
	printf("%d\n",points);
	return 0;
} 
\end{lstlisting}

\begin{note}[要点]
	善用标志变量, 标志变量的初始值必须是真实存在的值，不要想当然。
	
	样例数据作为初始化数据，调试时注释掉输入语句，便于进行快速调试程序。
\end{note}
