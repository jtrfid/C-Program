%%%%%%%%%%%%%%%%%%%%% chapter.tex %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% sample chapter
%
% Use this file as a template for your own input.
%
%%%%%%%%%%%%%%%%%%%%%%%% Springer-Verlag %%%%%%%%%%%%%%%%%%%%%%%%%%
%\motto{Use the template \emph{chapter.tex} to style the various elements of your chapter content.}
\chapter{第3次机试练习: 继续分支与循环练习}

\section{最大公约数}	
最大公约数(GCD)指某几个整数共有因子中最大的一个，最大公约数具有如下性质，

gcd(a,0)=a

gcd(a,1)=1

因此当两个数中有一个为0时，gcd是不为0的那个整数，当两个整数互质时最大公约数为1。

输入两个整数a和b，求最大公约数

输入说明：

输入为两个正整数a和b（0<=a,b<10000），a和b之间用空格分隔，

输出说明：

输出其最大公约数

输入样例：

样例1输入

2 4

样例2输入：

12 6

样例3输入：

3 5

输出样例：

样例1输出

2

样例2输出

6

样例3输出

1

\newpage
\begin{lstlisting}
#include <stdio.h>
// 递归函数
int gcd(int a,int b)
{
	if(b==0) return a;   // 公约数就是a
	return gcd(b,a%b);   // 递归调用
}

int main() // 调用递归函数
{
	int a,b,t;
	scanf("%d%d",&a,&b);
	if(a<b) { t=a; a=b; b=t; } // 交换a,b 
	printf("%d\n",gcd(a,b));   // 函数调用 
	return 0;	
}

int main1() // 暴力循环求解, 效率低。
{
	int a,b,t=-1,i;//t给初值是好习惯，否则下面程序逻辑有可能使t得到随机值。 
	scanf("%d%d",&a,&b); // 机试系统不要想当然给提示语句, 除非题目要求  
	if(a<b) { t=a; a=b; b=t; } // 交换a,b,使a是较大者 
	if(b==0) 
	{
		t=a; // 考虑分母为0的情况，比如：5,0的最大公约数为5 
	} 
	else
	{
		for(i=b;i>0;i--)
		{
			if(a%i==0 && b%i==0)
			{
				t=i; break; // 求得最大公约数，a,b互质, 必然t=1 
			}
		}
	}
	printf("%d\n",t);
	return 0;	
}

int main2() // 利用欧几里得定理循环求解, 效率高。
{
	int a,b,r,t;
	scanf("%d%d",&a,&b); // 机试系统不要想当然给提示语句, 除非题目要求
	if(a<b) { t=a; a=b; b=t; } // 交换a,b,使a是较大者
	while(1)
	{
		if(b==0) { t=a; break; } // 分母为0时, a就是最大公约数
		r = a%b; 
		if(r==0) {t=b; break;} // b就是最大公约数
		a=b; b=r; // 准备下一轮迭代   
	}
	printf("%d\n",t);// 输出最大公约数
	return 0;
}

int main3() // 利用欧几里得定理循环求解, 效率高。
{
	int a,b,r,t;
	scanf("%d%d",&a,&b); // 机试系统不要想当然给提示语句, 除非题目要求
	if(a<b) { t=a; a=b; b=t; } // 交换a,b,使a是较大者
	if (b==0) // 考虑分母为0的情况，比如：5,0的最大公约数为5 
	{
		printf("%d\n",a);
	}
	else
	{
		// 排除了分母为0时不能求余数的情况 
		while((r=a%b)!=0) // a/b的余数赋值给r,r不等于0时执行循环体 
		{	
			a=b; 
			b=r; 
		}
		printf("%d\n",b);
	}
	return 0; // 主函数结束
}	

int main4() // 体会函数结束语句return的使用
{
	int a,b,r,t;
	scanf("%d%d",&a,&b); // 机试系统不要想当然给提示语句, 除非题目要求
	if(a<b) { t=a; a=b; b=t; } // 交换a,b,使a是较大者
	if (b==0) // 考虑分母为0的情况，比如：5,0的最大公约数为5 
	{
		printf("%d\n",a);
		return 0;  // 主函数结束 
	}
	// 排除了分母为0时不能求余数的情况 
	while((r=a%b)!=0) // a/b的余数赋值给r,r不等于0时执行循环体 
	{
		a=b; b=r; // 准备下一轮迭代   
	}
	printf("%d\n",b);
	return 0;	// 主函数结束 
}
\end{lstlisting}

\begin{figure}[H]
	\centering
	\caption{递归函数\lstinline|int gcd(int a,int b)|中系统内部维护的`栈'结构示意图}	
	\begin{tikzpicture}
	\node[] (tab) {
		\begin{tabular}{|c|c|}
		\hline
		参数a,b & 递归调用\lstinline|gcd(a,b)=gcd(b,a%b);|\\
		\hline
		a=6,b=0 & gcd(6,0)=6; 6就是公约数, 结束递归, 开始出栈\\
		\hline
		a=12,b=6 & \lstinline|gcd(12,6)=gcd(6,12%6)=gcd(6,0);|\\
		\hline
		a=18,b=12 & \lstinline|gcd(18,12)=gcd(12,18%12)=gcd(12,6);|\\
		\hline
		\end{tabular}
	};
	\node[above] at(tab.north) {例1: 计算gcd(18,12)};
	\path[->,very thick]
	($(tab.north west)+(-0.5cm,0)$) edge[red] node[left] {入栈} ($(tab.south west)+(-0.5cm,0)$)
	($(tab.south east)+(0.5cm,0)$) edge[blue] node[right] {出栈} ($(tab.north east)+(0.5cm,0)$)
	($(tab.south west)+(-0.8cm,-0.2cm)$) edge[-,double] ($(tab.south east)+(0.8cm,-0.2cm)$)
	; 
	\end{tikzpicture}
	
	\begin{tikzpicture}
	\node[] (tab) {
		\begin{tabular}{|c|c|}
		\hline
		参数a,b & 递归调用\lstinline|gcd(a,b)=gcd(b,a%b);|\\
		\hline
		a=1,b=0 & gcd(1,0)=1; 1就是公约数, 结束递归, 开始出栈\\
		\hline
		a=2,b=1 & \lstinline|gcd(2,1)=gcd(1,2%1)=gcd(1,0);|\\
		\hline
		a=3,b=2 & \lstinline|gcd(3,2)=gcd(2,3%2)=gcd(2,1);|\\
		\hline
		a=2,b=3 & \lstinline|gcd(2,3)=gcd(3,2%3)=gcd(3,2);|\\
		\hline
		a=5,b=2 & \lstinline|gcd(5,2)=gcd(2,5%2)=gcd(2,3);|\\
		\hline
		a=32,b=5 & \lstinline|gcd(32,5)=gcd(5,32%5)=gcd(5,2);|\\
		\hline
		a=37,b=32 & \lstinline|gcd(37,32)=gcd(32,37%32)=gcd(32,5);|\\
		\hline
		\end{tabular}
	};
	\node[above] at(tab.north) {例2: 计算gcd(37,32)};
	\path[->,very thick]
	($(tab.north west)+(-0.5cm,0)$) edge[red] node[left] {入栈} ($(tab.south west)+(-0.5cm,0)$)
	($(tab.south east)+(0.5cm,0)$) edge[blue] node[right] {出栈} ($(tab.north east)+(0.5cm,0)$)
	; 
	\end{tikzpicture}
\end{figure}

\begin{note}[欧几里得定理]
	\begin{lstlisting}[frame=none]
	a(大),b(小)的最大公约数: 因为: a=mb+r, m=a/b; r=a%b, $\Rightarrow$a,b的公约数能整除b和r.
	r=a%b,r为0, 则b就是最大公约数。否则迭代循环, a=b，b=r, 直到余数为零, 则分母就是最大公约数。
	\end{lstlisting}
\end{note}

\begin{note}
	预习函数及递归函数的使用。
\end{note}

\section{角谷定理}
角谷定理定义如下：
对于一个大于1的整数n，如果n是偶数，则n = n / 2。如果n是奇数，则n = 3 * n +1，反复操作后，n一定为1。

例如输入22的变化过程： 22 ->11 -> 34 -> 17 -> 52 -> 26 -> 13 -> 40 -> 20 -> 10 -> 5 -> 16 -> 8 -> 4 -> 2 -> 1，数据变化次数为15。

输入一个大于1的整数，求经过多少次变化可得到自然数1。

输入说明	

输入为一个整数n，1<n<100000。

输出说明	

输出变为1需要的次数

输入样例

样例1输入

22

样例2输入

33

输出样例

样例1输出

15

样例2输出

26

\begin{lstlisting}
#include <stdio.h>
int main()
{
	int n,i=0; // 变量i用于计数的辅助变量
	scanf("%d",&n);
	// 因为题目输入假设$n>1$, 因此不必考虑n=1时的情况
	while(n!=1)  // n不等于1时执行循环体中的语句
	{
		if(n%2==0) n=n/2;
		else n=3*n+1;
		i++;
	} 
	printf("%d\n",i);
	return 0;	
}

// 含程序调试语句，不吝惜写一些printf语句，观察程序的执行过程。 
int main()
{
	int n=22,i=0; // 变量i用于计数的辅助变量
	//scanf("%d",&n); // 调试时可以注释掉输入语句, 改变变量n的值，观察执行过程 
	
	printf("%d->",n);
	while(n!=1)  // n不等于1时执行循环体中的语句
	{
		if(n%2==0) 
		{ 
			n=n/2;
		} 
		else 
		{
			n=3*n+1;
		}
		printf("%d->",n);
		i++;
	} 
	printf("\n总共变化次数%d\n",i);
	return 0;	
}
\end{lstlisting}

\begin{note}
	试着用\lstinline|do{ }while(); for(;;)|改写此程序, 执行相同功能。
\end{note}

\section{整数分析}
给出一个整数n（0<=n<=100000000）。求出该整数的位数，以及组成该整数的所有数字中的最大数字和最小数字。

输入说明
	
输入一个整数n（0<=n<=100000000）

输出说明
	
在一行上依次输出整数n的位数，以及组成该整数的所有数字中的最大数字和最小数字，各个数字之间用空格分隔。

输入样例
	
217

输出样例
	
3 7 1

\begin{lstlisting}
#include <stdio.h>
// 循环除10取余是整数分解的基本技巧
int main()
{
	int i = 0, n, bit, max, min;
	scanf("%d",&n);
	while(n) // 等效于 while(n!=0)
	{
		bit = n%10; // 获取n的最低为
		// 切记: 初始化时，假设的max和min必须是实际存在的数。
		if(i == 0) // 初始化: 原始n的最低位设为最大和最小数字
		{
			max = min = bit;
		}  
		else
		{
			if(bit > max) max = bit;
			if(bit < min) min = bit;
		}
		n /= 10; // 去除最低位
		i++;
	} 
	// (i == 0 ? 1 : i)是条件表达式, 表达式的值是:
	// 如果i==0,则表达式的值为1否则表达式的值是i
	printf("%d %d %d\n",(i == 0 ? 1 : i),max,min); //考虑原始n==0的情况 
	return 0;
} 
\end{lstlisting}

\begin{note}[知识点]
  \begin{enumerate}
  	\item 整数数位分解是基本编程练习之一。
  	\item 切记: 初始化时，假设的max和min必须是实际存在的数。比如不能想当然假设max=1000, min=0.
  	\item 注意审题: ``输入一个整数$n,(0<=n<=100000000)$'', 因此, 0也是一个合法输入。
  \end{enumerate}
  
\end{note}

\section{冰箱温度预测}
编写一个程序，用于预测冰箱断电后经过时间t(以小时为单位)后的温度T。已知计算公式如下所示
\[ T=\frac{4t^2}{t+2}-20 \]

输入说明	

输入两个整数h和m表示冰箱断电后经过的时间，h表示小时，m表示分钟

输出说明
	
输出冰箱断电后经过时间t(以小时为单位)后的温度T，保留两位小数

输入样例
	
2 0

输出样例
	
-16.00

\begin{lstlisting}
#include <stdio.h>
int main()
{
	int h,m;
	float t,T;
	scanf("%d%d",&h,&m);
	t = h + m/60.0;      // 必须是60.0, why?
	T = 4*t*t/(t+2)-20;  // 优先级保证了计算的正确性, why?
	printf("%.2f\n",T);
	
	return 0;
}
\end{lstlisting}

\begin{note}[知识点]
	整数/整数, 表达式的值是整数部分, 自动舍去小数部分。
\end{note}

\section{除法计算器}	
小明的弟弟刚开始学习除法，为了检查弟弟的计算结果是否正确，小明决定设计一个简单计算器程序来验算。

输入说明
	
输入数据由四个整数m，n，q，r构成，m为被除数，n为除数，q和r为小明的弟弟计算出的商和余数。整数之间用空格分隔，所有整数取值范围在$(-100000\sim 100000)$, n不为0。

输出说明
	
如果验算结果正确，输出yes，否则输出正确的商和余数

输入样例：

样例1：

10 3 3 1

样例2：

10 3 3 2

输出样例	

样例1输出：

yes

样例2输出：

3 1

\begin{lstlisting}
#include <stdio.h>
int main()
{
	int m,n,q,r;
	scanf("%d%d%d%d",&m,&n,&q,&r);
	if(m==q*n+r && q==m/n && r==m%n) printf("yes\n");
	else printf("%d %d\n",m/n,m%n); 
	return 0;
} 
\end{lstlisting}

\begin{note}
	改变题设条件，修改此程序，进行各种表达式计算练习, 分析优先级。 如果n=0时, 如何处理。
\end{note}


\section{自然数分解}
任何一个自然数m的立方均可写成m个连续奇数之和。例如：
\begin{align*}
1^3 &=1\\
2^3 &=3+5\\
3^3 &=7+9+11\\
4^3 &=13+15+17+19
\end{align*}

编程实现：输入一自然数n, 求组成$n^3$的n个连续奇数。

输入说明

一个正整数n, 0<n<30 。

输出说明

输出n个连续奇数, 数据之间用空格隔开,并换行

输入样例

4

输出样例

13 15 17 19

\begin{lstlisting}
#include <stdio.h>
// 从估计的第一个奇数开始，循环迭代求解。
int main()
{
	int n,i,j,sum,first;
	scanf("%d",&n);
	
	// 第一个可能的奇数：
	if(n%2) first = n;    // n是奇数 
	else first = n + 1;   // n是偶数 
	
	while(1)
	{
		sum = 0; // 每趟内层循环前，必须置0 
		// 从first开始，n个连续奇数, i：表示连续奇数，j：计数。 
		for(i = first,j = 1; j <= n; i += 2,j++ ) 
		{
			sum += i; // 连续奇数累加 
			if(sum == n*n*n) 
			{
				// 输出 
				for(i = first,j = 1; j <= n; i += 2,j++) 
				{
					if (j == n)printf("%d\n",i);
					else printf("%d ",i);
				}
				return 0; // 函数结束 
			}
		}
		first += 2; 
	}
	return 0;
} 
\end{lstlisting}

\begin{note}[要点]
	再次强调进入内层循环前, 相关变量的初始化; 以及标志变量(如本例first)的使用技巧。
\end{note}

\section{选号程序}
小明决定申请一个新的QQ号码，系统随机生成了若干个号码供他选择。小明的选号原则是：
\begin{enumerate}
	\item 选择所有号码中各位数字之和最大的号码。
	\item 如果有多个号码各位数字之和相同则选择数值最大的号码。
\end{enumerate}

请你写一个程序帮助小明选择一个QQ号码。

输入说明

输入数据由两行构成，第一行为一个整数n表示有n个待选号码(0<n<100)，第二行有n个正整数，表示各个待选的号码，每个号码长度不超过9位数。每个号码之间用空格分隔，且每个号码都不相同。

输出说明

输出根据小明的选号原则选出的号码。

输入样例

5

10000 11111 22222 333 1234

输出样例

22222

\begin{lstlisting}
#include <stdio.h>
// 在循环语句中, 读取备选qq号, 计算各位之和, 依据筛选条件选取qq号
int main() 
{ 
	// 关键变量含义说明: 
	// select_qq,select_sum表示备选qq及其各位之和
	// qq,sum表示当前读取的qq及其各位和 
	int i,n,select_qq,select_sum,qq,sum,tmp;
	scanf("%d",&n);
	for(i=0;i<n;i++) // 注意条件表达式, 表明i的最大值是n-1, 因为i是0开始的, 因此共执行n次循环
	{
		scanf("%d",&qq); // 读取当前备选qq号
		tmp=qq; // 保存到临时变量中，因为下面的循环语句要更改。 
		sum=0;  // 当前读取qq号的各位之和。 注意: 一定要初始化，否则上一个备选号的sum值会带入本轮循环中。 
		while(tmp) // 计算各位之和 
		{
			sum+=tmp%10;
			tmp/=10;
		}
		// 第1轮迭代(i==0), 当前读取的qq就是所选, 其它根据题设条件选号
		// 因为三个表达式为||运算, 从左到右依次计算各表达式的值, 如果为真，则不会计算后边表达式。
		// 因此, 当i==0时不会计算其它两个表达式的值, if条件为真。 
		if(i==0 || sum>select_sum || (sum==select_sum && qq>select_qq))
		{ 
			select_qq=qq;
			select_sum=sum; // i==0时，select_sum初值为第一个号码各位之和.
		} 
	}
	printf("%d",select_qq);
	return 0;
} 

// 解法2: 用二维数组存储所有qq号及其各位和 
#define N 100 // 估计最大数组长度 
int main1() 
{
	// 二维数组No, 第一列表示qq号, 第二列表示该qq号的各位数字之和。 
	int i,n,No[N][2],tmp,sum,max=0,largest=0,select;
	scanf("%d",&n);
	// 筛选条件2
	for(i=0;i<n;i++)
	{
		scanf("%d",&No[i][0]);
		tmp=No[i][0];
		sum=0;  // 一定初始化 
		while(tmp)
		{
			sum+=tmp%10;
			tmp/=10;
		}
		No[i][1]=sum;
		if(sum>=max) max=sum; 
	}
	// 筛选条件1
	for(i=0;i<n;i++)
	{
		if(No[i][1]==max) // 备选号码
		{
			if(No[i][0]>=largest)
			{
				select=No[i][0];
				largest=No[i][0];
			}
		} 
	}
	printf("%d",select);
	return 0;
} 
\end{lstlisting}

\begin{note}[要点]
	\begin{enumerate}
		\item ||和 \&\&运算从左到右执行，取得结果，则不执行后面的表达式。\\
		取得结果的含义是: \\
		if (条件1||条件2||条件3)运算中, 只要有一个条件表达式为真(非0)，即整个条件()结果即为真。 \\
		if (条件1 \&\&条件2 \&\& 条件3)运算中, 只要有一个条件表达式为假(0)，即整个条件()结果即为假。
		\item 比较两种解法的优缺点。
		\item 本例是循环迭代的范例, 应反复演练, 领会迭代程序的编程技巧。
		\item 试着定义函数, 改写此程序。
		\item 本题不必使用排序算法，使程序复杂化。
	\end{enumerate}	
\end{note}


