/************************************************************************** 
试题编号	56
试题名称	单元测试2-题目2-表达式求值
时间限制:	1 秒
内存限制:	256MB
问题描述	
问题描述
求一个表达式的值。表达式由两个非负整数x，y和一个运算符op构成。
这两个整数和运算符的顺序是随机的，可能是”x op y”， “op x y”或者 “x y op”，
例如，“25 + 3”表示25加3，“5 30 *” 表示5乘以30，“/ 600 15”表示600除以15。
输入说明
输入为一个表达式，表达式由两个非负整数x，y和一个运算符op构成，x，y和op之间以空格分隔，但顺序不确定。
x和y均不大于10000000，op可以是+，-,*，/，%中的任意一种，分表表示加法，减法，乘法，除法和求余。
除法按整数除法求值，输入数据保证除法和求余运算的y值不为0。
输出说明
输出表达式的值。
输入样例
5 20 *
输出样例
100
提示信息
 ************************************************************************/
 // 思路：gets函数读取字符串，遍历字符串，根据op字符是"非数字字符"的特点，判断表达式的三种形式。
 // 编写独立函数(1) 根据op,x,y计算表达式的值。（2）提取[*p1,*p2]之间的数字字符串，并返回对应的整数值(x或y)。 
  
 #include <stdio.h>
// 估计字符串最大长度，存储有效字符(N-1)个，预留最后一个字符'\0' 
 #define N 20 
 
 // 根据参数，计算表达式的值 
 int compute(char op,int x,int y)
 {
 	int result = -1;
 	switch(op)
 	{
 		case '+': result = x+y; break;
 		case '-': result = x-y; break;
 		case '*': result = x*y; break;
 		case '/': if(y != 0) result = x/y; break;
 		case '%': if(y != 0) result = x%y; break;
	}
	return result;
 }
 
  // 提取[*p1,*p2]之间的数字字符串，并返回对应的整数值(xy)。  
 int xy(char *p1,char *p2)
 {
 	int result = 0;
 	// 删除前后缀空格 
 	while(*p1 == ' ') p1++; // 使p1,p2指向非空格
 	while(*p2 == ' ') p2--; 
	for(; p1 <= p2; p1++)
	{
		result += *p1 -'0'; // 1 = '1' - '0'
		if(p1 != p2) result *= 10; // 非最后一个字符，左移一位十进制数 
	}
	return result;
 }
 
 int main()
 {
	char s[N],*p1,*p2,op; // 借助p1,p2指针变量，扫描字符串 
	int x,y;
	gets(s); // 不能使用scanf("%s",s); 空格将会终止
	
	p1 = s; // p1指向字符串首地址 
	while(*p1 == ' ') p1++; // 使p1指向非空格
	// 首先判断第一个字符是运算符, op x y
	if (*p1 < '0' || *p1 > '9')
	{
	    op = *p1;
		p1++; // 掠过op 
		while(*p1 == ' ') p1++; // 使p1指向非空格
		p2 = p1; 
		while(*p2 != ' ') p2++; // x空格
		x = xy(p1,p2);
		p1 = p2;
		while(*p2 != '\0') p2++; // p2指向'\0' 
	    y = xy(p1,p2 - 1); // p2 - 1是最后一个有效字符 
	} 
	else // x y op 或 x op y 
	{
		p2 = s; // p2指向字符串首地址 
		while(*p2 != '\0') p2++; // p2指向'\0'
		p2--;
		while(*p2 == ' ') p2--; // p2指向非空格
		if (*p2 < '0' || *p2 > '9') // x y op 
		{
			op = *p2;
			p2--; // 掠过op
	        while(*p2 == ' ') p2--; // p2指向非空格
	        p1 = p2;
	        while(*p1 != ' ') p1--; // 空格y
	        y = xy(p1,p2);
	        x = xy(s,p1);
		}
		else // x op y 
		{
			p1 = s;
			while(*p1 == ' ') p1++; // 使p1指向非空格
			p2 = p1;
			while(*p2 != ' ') p2++; // x空格
			x = xy(p1,p2);
			while(*p2 == ' ') p2++; // op
			op = *p2;
			p1 = p2 + 1; // 掠过op
			p2 = p1;
			while(*p2 != '\0') p2++; // p2指向'\0'
			y = xy(p1,p2 - 1); // p2 - 1是最后一个有效字符 	
		} 
	}
    //printf("====%c,%d,%d\n",op,x,y);
    printf("%d\n",compute(op,x,y)); 
 	return 0;
 }
