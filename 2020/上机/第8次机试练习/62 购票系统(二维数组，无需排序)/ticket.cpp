/************************************************************************
试题编号	62
试题名称	期末测试-题目4-购票系统
时间限制:	1 秒
内存限制:	256MB
问题描述	
问题描述
请实现一个铁路购票系统的简单座位分配算法，来处理一节车厢的座位分配。 
假设一节车厢有20排、每一排5个座位。为方便起见，我们用1到100来给所有的座位编号，第一排是1到5号，第二排是6到10号，依次类推，第20排是96到100号。 
　　购票时，一个人可能购一张或多张票，最多不超过5张。如果这几张票可以安排在同一排编号相邻的座位，则应该安排在编号最小的相邻座位。否则应该安排在编号最小的几个空座位中（不考虑是否相邻）。 
假设初始时车票全部未被购买，现在给了一些购票指令，请你处理这些指令，输出购票结果。 
例如：若一次购买2，5，4，2张票得到的购票结果为： 
1) 购2张票，得到座位1、2。 
2) 购5张票，得到座位6至10。 
3) 购4张票，得到座位11至14。 
4) 购2张票，得到座位3、4。 
输入说明
输入由两行构成。 
第一行包含一个整数n，表示购票指令的数量，1 ≤ n ≤ 100。 
第二行包含n个整数，每个整数p在1到5之间，表示要购入的票数，相邻的两个整数之间使用一个空格分隔，所有购票数量之和不超过100。 
输出说明
输出n行，每行对应一条购票指令的处理结果。即对于购票指令p，按从小到大排序输出p张车票的编号。 
输入样例
4 
2 5 4 2 
输出样例
1 2 
6 7 8 9 10 
11 12 13 14 
3 4 
提示信息
 ************************************************************************/
 // 思路：使用二维数组模拟售票座位，元素为0值，表示座位未售出, 元素为1代表对应座位已输出。
 // 定义独立函数，根据售票指令查询待售座位；定义独立函数，模拟售票操作。 
 
 // 注意：随然要求排序输出，但是选票过程就是按照从小到大的顺序选座位，因此并不需要编写排序函数。 
  
 #include <stdio.h>
 // 估计二维数组最大行数和列数 
 #define M 20
 #define N 5 
 
 // 初始化 
 // 二维数组seat代表座位，元素为0值，表示座位未售出, 元素为1代表对应座位已输出。
 // m,n是seat实际的行数和列数 
 void init(int seat[][N],int m,int n)
 {
 	int i,j;
 	for(i = 0; i < m; i++)
 		for(j = 0; j < n; j++)
 		    seat[i][j] = 0;	 
 }
 
 // 根据购票数，查询本购票指令，首座位对应的行索引(从0开始) 
 // 二维数组seat代表座位，元素为0值，表示座位未售出, 元素为1代表对应座位已输出。
 // m,n是seat实际的行数和列数，tickets购票数  
 int search(int seat[][N],int m,int n,int tickets)
 {
 	int i,j;
	int zeroNum; // 表示某行未售出的座位数
	int row = 0; 
 	for(i = 0; i < m; i++)
 	{
 	    zeroNum = 0;
 		for(j = 0; j < n; j++)
 		{
		    if (seat[i][j] == 0) zeroNum++;
		}
		if(zeroNum >= tickets) 
		{
			row = i;
			break;
		}
	}
	return row;
 }
 
 // 售票 
 // 二维数组seat代表座位，元素为0值，表示座位未售出, 元素为1代表对应座位已输出。
 // m,n是seat实际的行数和列数，tickets购票数  
 void salse(int seat[][N],int m,int n,int tickets)
 {
 	int i,j,count = 0, flag = 0;
	int row = search(seat,m,n,tickets); // 获取本购票指令，首座位对应的行索引(从0开始)  
 	for(i = row; i < m; i++)
 	{
 		for(j = 0; j < n; j++)
 		{
		    if (seat[i][j] == 0) 
			{ 
			  seat[i][j] = 1;
			  printf("%d ",i*n+j+1); // 打印座位编号 
			  count++;
			  if(count >= tickets)
			  {
			  	flag = 1; break;
			  }
			} 
		}
		if(flag == 1) break;
	}
	printf("\n"); // 换行 
 }
 
 int main()
 { 
	int seat[M][N];    // 二维数组seat代表座位，元素为0值，表示座位未售出, 元素为1代表对应座位已输出。
	int i, m = 20, n = 5; // m,n是seat实际的行数和列数
	int pNum,tickets;  // 售票指令数和票数 
	
	// 初始化 
    init(seat,m,n);
	
 	scanf("%d",&pNum);
 	// 输入同时，处理售票。因此不需要使用数组存储pNum和tickets 
 	for(i = 0; i < pNum; i++)
 	{
		scanf("%d",&tickets);
		salse(seat,m,n,tickets);
	}
 		
 	return 0;
 }
