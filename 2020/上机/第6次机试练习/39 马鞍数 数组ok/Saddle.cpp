/************************************************************************
试题编号	21
试题名称	马鞍点
时间限制:	2 秒
内存限制:	10000MB
问题描述	
问题描述
请写一个程序，找出给定矩阵的马鞍点。若一个矩阵中的某元素在其所在行最小而在其所在列最大，则该元素为矩阵的一个马鞍点。
输入说明
输入数据由m+1行构成，第一行只有两个整数m和n（0<m<100,0<n<100），分别表示矩阵的行数和列数，接下来的m行、每行n个整数表示矩阵元素（矩阵中的元素互不相同），整数之间以空格间隔。
输出说明
在一行上输出马鞍点的行号、列号（行号和列号从0开始计数）及元素的值（用一个空格分隔），之后换行；若不存在马鞍点，则输出一个字符串“no”后换行。
输入样例
4 3 
11 13 121 
407 72 88 
23 58 1 
134 30 62 
输出样例
1 1 72
提示信息
 ************************************************************************/
 // 思路：定义函数计算单个元素a[i,j]是否是马鞍点，主程序遍历二维数组，调用此函数。
 // 避免过多循环嵌套，不易出错，简化程序设计。

 #include <stdio.h>
 // 估计的二维数组最大行列数 
 #define M 100
 #define N 100
   
 // 判断a[row,col]是否是马鞍点,是: 返回1；否则返回0
 // m,n是二维数组实际行列数 
 int compute(int a[][N], int m, int n, int row, int col)
 {
 	int i,element = a[row][col]; 
 	// element在其所在行最小而在其所在列最大 
 	for(i = 0; i < n; i++)
       if(a[row][i] < element) return 0; // 不是马鞍点，直接返回0 
	for(i = 0; i < m; i++)
       if(a[i][col] > element) return 0; // 不是马鞍点，直接返回0
	return 1;	// 如果执行至此，肯定是马鞍点，直接返回0 
 }
 
 int main()
 {
 	int matrix[M][N]; // 按照估计的最大行列数定义二维数组 
	int i,j,m,n,flag = 0; 
	
 	scanf("%d%d",&m,&n); // 实际行列数 
 	
 	// input
 	for(i = 0; i < m; i++)
 		for(j = 0; j < n; j++) 
			scanf("%d",&matrix[i][j]);
	
	// 遍历二维数组, 判断马鞍点		
 	for(i = 0; i < m; i++)
 	{
 		for(j = 0; j < n; j++) 
		{
			if(compute(matrix,m,n,i,j))
			{
				printf("%d %d %d\n",i,j,matrix[i][j]);
				flag = 1;
			}
 				
		}
    }	
    if (!flag) printf("no\n");
 		
 	return 0;
 }
