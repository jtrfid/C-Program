%%%%%%%%%%%%%%%%%%%%%%%%%% lecture-12
%\begin{frame}[shrink]
%  \frametitle{lecture-12 主要内容}
%  \framesubtitle{用函数实现模块化程序设计}
%  %\tableofcontents[hideallsubsections]
%  \tableofcontents
%\end{frame}

\section{使用函数进行模块化程序设计}

\begin{frame}[shrink,fragile]{为什么使用函数(1)}
\tiny
\vspace{-0.2cm}
\begin{columns}[T]
\column{0.4\textwidth}
\begin{beamerboxesrounded}{函数调用}
\begin{lstlisting}
#include<stdio.h>
#include<math.h>
int main() // 主函数
{
   int a;
   // 库函数调用
   scanf("%d",&a); 
   a=(int)fabs((double)a); 
   printf("%d\n",a);
   return 0; 
}
\end{lstlisting}
\end{beamerboxesrounded}
\column{0.6\textwidth}
\begin{beamerboxesrounded}{函数定义}
\begin{lstlisting}
int scanf(char format[], args, ...)
{ ...;
  return 整型值;
}
int printf(char format[], args, ...)
{ ...;
  return 整型值;
}
double fabs(double a)
{ // 模拟代码，没有考虑精度
  if(a<0) return -a;
  else return a;
}
\end{lstlisting}
\end{beamerboxesrounded}
\end{columns}
\end{frame}

\begin{frame}[shrink,fragile]{为什么使用函数(2)}
\tiny
\vspace{-0.2cm}
\begin{columns}[T]
\column{0.5\textwidth}
\begin{beamerboxesrounded}{函数调用}
\begin{lstlisting}
#include<stdio.h>
#include<string.h>
int main() // 主函数
{
   int a;
   char s1[81],char s2[81]="1234";
   // 库函数调用 
   strcpy(s1,s2); 
   a=strcmp(s1,s2);
   printf("%d ",a);
   printf("%d\n",strlen(s1));
   return 0; 
}
\end{lstlisting}
\end{beamerboxesrounded}
\column{0.5\textwidth}
\begin{beamerboxesrounded}{函数定义}
\begin{lstlisting}
char[] strcpy(char s1[],char s2[])
{ ...; return s1; 
}
int strcmp(char s1[],char s2[])
{  ...;  return 整型值; // 1,-1,0
}
int strlen(char s[])
{
  int len=0;
  while(s[len]!='\0') len++;
  return len;
}
\end{lstlisting}
\end{beamerboxesrounded}
\end{columns}
\end{frame}

\begin{frame}[shrink,fragile]{利用函数进行功能分解 --- 简化程序设计的有效手段}
\vspace{-0.3cm}
\begin{columns}[T]
\column{0.5\textwidth}
\begin{beamerboxesrounded}{功能分解, 函数调用}
\begin{lstlisting}
#include<stdio.h>
#include<math.h>
int add(int a,int b); // 函数原型声明
void output(double a);
int main() // 主函数
{
  int a=10,b=20,c;
  //传递参数a,b的值, 计算结果赋值给变量c 
  c=add(a,b);  // 函数调用
  output(10.5*c); // 函数调用
  return 0; 
}
\end{lstlisting}
\end{beamerboxesrounded}
\column{0.5\textwidth}
\begin{beamerboxesrounded}{分解功能实现, 函数定义}
\begin{lstlisting}
// 通过参数a,b的值, 进行相关计算, 返回整型数据给调用者
int add(int a,int b)
{  return a+b; }  // 返回整型值

// 通过参数a的值, 进行相关计算, 不需要返回数据
void output(double a)
{  
   printf("%lf\n", sqrt(a)); // 函数中可调用别的函数
}
\end{lstlisting}
\end{beamerboxesrounded}
\end{columns}
%~\\
\end{frame}

\begin{frame}{使用函数进行程序设计的优点}
\begin{enumerate}
	\setlength{\itemsep}{.5cm}
	\item 使用函数可使程序清晰、精炼、简单、灵活。
	\item 函数就是功能。每一个函数用来实现一个特定的功能。函数名应反映其代表的功能。
	\item 在设计较大程序时，往往把它分为若干个程序模块，每一个模块包括一个或多个函数，每个函数实现一个特定的功能。
	\item 一个C程序可由一个主函数和若干个其他函数构成。由主函数调用其他函数，其他函数也可以互相调用。	
\end{enumerate}
\end{frame}

%\subsection{函数三要素: 函数原型声明, 函数定义, 函数调用}

\begin{frame}[shrink,fragile]{函数三要素: 函数原型声明, 函数定义, 函数调用}
\vspace{-0.2cm}
\begin{columns}[T]
\column{0.5\textwidth}
\begin{beamerboxesrounded}{函数原型声明, 函数调用}
\begin{lstlisting}
#include<stdio.h> // 库函数原型声明
// 函数原型声明, 使编译器认识这个函数，如果函数定义在调用之前，可省略声明
int add(int a,int b); 
void output(double a);
int main() // 主函数
{
   int a=10,b=20,c;
   // 函数调用, 执行函数功能
   c=add(a,b); // c接收函数返回值
   output(10.5*c); // 无返回值
   return 0; 
}
\end{lstlisting}
\end{beamerboxesrounded}
\column{0.5\textwidth}
\begin{beamerboxesrounded}{函数定义, 定义函数功能}
\begin{lstlisting}
// 通过参数a,b的值, 进行相关计算, 返回整型数据给调用者
int add(int a,int b)
{  return a+b; }  // 返回整型值

// 通过参数a的值, 进行相关计算, 不需要返回数据
void output(double a)
{  
   printf("%lf\n", sqrt(a)); // 函数中可调用别的函数
}
\end{lstlisting}
\end{beamerboxesrounded}
\end{columns}
~\\
\end{frame}

%\subsection{函数定义: int\, add(int a,int b)\{\quad\}}

\begin{frame}[shrink,fragile]{函数定义: int\, add(int a,int b)\{\quad\}}
\textbf{函数定义: } 返回类型\, 函数名(参数类型\, 参数, $\cdots$) $\{\cdots ; \}$
\begin{lstlisting}
int add(int a, int b)
{  ...;
   return 整型值; // 必须含return语句, 函数执行结束, 并将返回值返回给调用者
}
double fun(void) // 无参函数, 等效 double fun() 
{  ...;
   return 双精度值; // 必须含return语句, 函数执行结束, 并将返回值返回给调用者
}
void output(double a) // 无返回值函数
{  ...;
   return; // 可选return语句(注意没有表达式), 仅表示函数执行结束
}
\end{lstlisting}
\end{frame}

\section{实参和形参间的数据传递(值传递和地址传递)}

\begin{frame}[shrink,fragile]{实参和形参间的数据传递(值传递)}
\vspace{-0.2cm}
\begin{tikzpicture}
\node[text width=0.55\textwidth,rounded corners,draw=none] (a) {
\vspace{-0.3cm}
\begin{lstlisting}
#include<stdio.h> // 库函数原型声明
// 函数原型声明, 使编译器认识这个函数
int max(int x,int y); 
int main() // 主函数
{
   // a,b,c局部变量, 作用域: 本函数
   int a=10,b=20,c; 
   scanf("%d%d",&a,&b);
   // 把此处的a,b值拷贝给函数形式参数x,y
   c=max(a,b); // 实际参数a,b 
   printf("较大者=%d\n",c); // 或
   printf("较大者=%d\n",max(a,b));
   return 0; 
}
\end{lstlisting}
};

\node[anchor=north west,text width=0.45\textwidth,rounded corners,draw=none] (b) at(a.north east) {
\vspace{-0.3cm}
\begin{lstlisting}
// 定义函数求形参x,y中的较大者并返回给调用者
int max(int x,int y) // 形式参数
{  
   // x,y,z局部变量,作用域: 本函数
   int z; 
   z = x>y ? x : y;
   return z; 
}
\end{lstlisting}
};

\node[anchor=north,text width=0.4\textwidth,rounded corners,fill=green,align=center] (c) at($(b.south)+(0,0.2cm)$) {
	main函数: c=max(a,b);
};

\node[anchor=north,text width=0.4\textwidth,rounded corners,fill=green,align=center] (d) at($(c.south)+(0,-1cm)$) {
	max函数: int max(int x,int y)
	
	\quad\quad\{return z; \}
};
\path[->,line width=1pt]
($(c.south)+(-1cm,0)$) edge[blue] node[align=left,anchor=east]{x=a的值\\y=b的值} ($(d.north)+(-1cm,0)$)

($(c.south)+(1cm,0)$) edge[red,<-] node[align=left,anchor=west]{c=z的值} ($(d.north)+(1cm,0)$)
;

\draw[dashed,red] (a.north east) -- (a.south east);
\end{tikzpicture}

%\textcolor{blue}{在调用函数过程中发生的实参与形参间的数据传递称为``虚实结合"。}
\end{frame}

\begin{frame}[shrink,fragile]{\small 实参和形参间的数据传递(地址传递, 形参是地址:指针变量)}
\vspace{-0.2cm}
\begin{tikzpicture}
\node[text width=0.55\textwidth,rounded corners,draw=none] (a) {
	\vspace{-0.3cm}
	\begin{lstlisting}
	#include<stdio.h> // 库函数原型声明
	// 函数原型声明, 使编译器认识这个函数
	int max(int *x,int *y); // 地址传递
	int main() // 主函数
	{
		int a=10,b=20,c; 
		scanf("%d%d",&a,&b);
		c=max(&a,&b); // 传递a,b的地址
		printf("较大者=%d\n",c);// 或
		printf("较大者=%d\n",max(&a,&b));
		printf("%X,%X\n",&a,&b); //63FE14,63FE18
		return 0; 
	}
	\end{lstlisting}
};

\node[anchor=south east,rounded corners,draw,blue,label=left:{\&a: 63FE14}] (a1) at($(a.south east)+(-0.5cm,0.6cm)$) {10};

\node[anchor=south east,rounded corners,draw,blue,label=left:{\&b: 63FE18}] (a2) at($(a1.south east)+(0,-0.8cm)$) {20};

\node[rounded corners,draw,dashed,red,fit=(a1) (a2),label=above:存储单元] {};

\node[anchor=north west,text width=0.5\textwidth,rounded corners,draw=none] (b) at(a.north east) {
	\vspace{-0.3cm}
	\begin{lstlisting}
	// 形参,实参共享同一存储单元
	int max(int *x,int *y)
	{  
		int z; 
		//*间接访问运算符,获取存储单元内容
		z = *x > *y ? *x : *y;
		printf("%X,%X\n",x,y); // 63FE14,63FE18
		return z; 
	}
	\end{lstlisting}
};

\node[anchor=north,text width=0.4\textwidth,rounded corners,fill=green,align=center] (c) at(b.south) {
	main函数: c=max(\&a,\&b);
};

\node[anchor=north,text width=0.4\textwidth,rounded corners,fill=green,align=center] (d) at($(c.south)+(0,-1cm)$) {
	max函数: int max(int *x,int *y)
};
\path[->,line width=1pt]
($(c.south)+(-1cm,0)$) edge[blue] node[align=left,anchor=east]{x=\&a\\y=\&b} ($(d.north)+(-1cm,0)$)

($(c.south)+(1cm,0)$) edge[red,<-] node[align=left,anchor=west]{c=z的值} ($(d.north)+(1cm,0)$)
;

\draw[dashed,red] (a.north east) -- (a.south east);
\end{tikzpicture}
\end{frame}

\begin{frame}[shrink,fragile]{\small 实参和形参间的数据传递(地址传递, 形参是地址:数组名), 倒置数组a的内容}
\vspace{-0.2cm}
\begin{tikzpicture}
\node[text width=0.55\textwidth,rounded corners,draw=none] (a) {
\vspace{-0.3cm}
\begin{lstlisting}
#include<stdio.h> 
void inv(int x[],int n); // x是地址传递
int main() 
{  int i, n, a[3]={10,20,30};
   scanf("%d",&n); // 输入3
   for(i=0; i<n; i++) scanf("%d",&a[i]);
   // 把实参a数组的地址拷贝给形参x, n的值拷贝给形式参数n
   inv(a,n); // 实参a数组的内容被改变
   for(i=0; i<n; i++) printf("%d ",a[i]);
   return 0; 
}
\end{lstlisting}
};
%%%%%
\node[anchor=south east,rounded corners,draw,blue,label=left:{a: 63FE14}] (a1) at($(a.south east)+(-2.2cm,0)$) {10};

\node[anchor=south east,rounded corners,draw,blue,label=left:{63FE18}] (a2) at($(a1.south east)+(0,-0.5cm)$) {20};

\node[anchor=south east,rounded corners,draw,blue,label=left:{63FE1C}] (a3) at($(a2.south east)+(0,-0.5cm)$) {30};

\node[rounded corners,draw,dashed,red,fit=(a1) (a3),label=above:调用前] {};
%%%%%
\node[anchor=west,rounded corners,draw,blue] (b1) at($(a1.east)+(0.7cm,0)$) {30};

\node[anchor=west,rounded corners,draw,blue] (b2) at($(b1.west)+(0,-0.5cm)$) {20};

\node[anchor=west,rounded corners,draw,blue] (b3) at($(b2.west)+(0,-0.5cm)$) {10};

\node[rounded corners,draw,dashed,red,fit=(b1) (b3),label=above:调用后] {};
%%%%%%%%%
\node[anchor=north west,text width=0.5\textwidth,rounded corners,draw=none] (b) at(a.north east) {
\vspace{-0.3cm}
\begin{lstlisting}
// 倒置数组x的内容, n是x的长度
// 要求x是地址传递
void inv(int x[],int n) 
// 编译器转换为: void inv(int *x,int n) 
{  
   int i,temp,m=(n-1)/2;
   //以中间元素为界, 前后元素交换
   for(i=0; i<=m; i++) 
   {
      temp=x[i]; 
      x[i]=x[n-1-i]; 
      x[n-1-i]=temp;
   }
   return; //可选, 函数执行完毕
}
\end{lstlisting}
};

\draw[dashed,red] (a.north east) -- (a.south east |- a3.south);
\end{tikzpicture}
\end{frame}

\begin{frame}[shrink,fragile]{值传递与地址传递的差异}
\vspace{-0.3cm}
\begin{itemize}
	\item 值传递, 对形参值的改变不会引起实参值的改变。
	\item 地址传递虽然不能改变实参的地址，但是对地址指向内容的改变会引起实参指向内容的改变。编译器视同指针变量和数组名均表示地址。
	\item 数组名表示数组元素在内存中的首地址, 数组元素是连续存放的。
	\item 用数组名作为参数传递，就是地址传递。在函数内部对数组元素的改变，就是改变实参数组元素的值。
\end{itemize}
\begin{tikzpicture}
\node[text width=.68\textwidth,rounded corners,draw] (a) {
	\vspace{-0.2cm}
	\begin{lstlisting}
	// a,b是地址传递, n是值传递
	void fun(double a[],int *b,int n)
	// 编译器转换为:  void fun(double *a,int *b,int n)
	{
		// 改变地址a指向的内容，就是改变实参数组的元素值
		a[1]=20.5; 
		*b=20; // 将会改变实参的值
		// n的改变不会影响实参的值
		n=30; 
	}
	\end{lstlisting}
};
\node[anchor=west,text width=.6\textwidth,rounded corners,draw] at(a.east)
{
	\vspace{-0.2cm}
	\begin{lstlisting}
	int main()
	{
		double a[2]={0.8,0.3}, int b=10;
		int n=2;
		// 实参a,b地址拷贝给形参a,b,
		// 实参n的值拷贝给形参n
		fun(a,&b,n); 
		printf("%d,%lf,%lf\n",n,a[0],a[1],b); 
		// 2,0.8,20.5,20 (值传递不变, 地址传递变)
	}
	\end{lstlisting}
};
\end{tikzpicture}

\end{frame}

\begin{frame}[shrink,fragile]{一维数组名和二维数组名作为函数参数的注意事项}
\vspace{-0.4cm}
\begin{columns}[T]
\column{0.5\textwidth}
%\begin{beamerboxesrounded}{一维数组}
\begin{lstlisting}
#define M 100 // 估计的数组的第一维长度
#define N 100 // 估计的数组的第二维长度
// 函数定义时省略第一维大小
// a[]表示a接受地址传递，以区别于值传递
void fun(int a[],int n)
{
   int i;
   for(i=0;i<n;i++) 
     printf("%d "a[i]);
   printf("\n");
}
// 函数调用
int x[M]={1，2，3，4，5};
fun(x,5);//调用时仅用数组名传递x的地址
\end{lstlisting}
%\end{beamerboxesrounded}
\column{0.5\textwidth}
%\begin{beamerboxesrounded}{二维数组}
\begin{lstlisting}[frame=leftline]
// 函数定义时不写第一维大小,第二维不能省略
void fun(int a[][N],int m,int n)
{
  int i;
  for(i=0;i<m;i++)
  {
    for(j=0;j<n;j++) 
      printf("%d "a[i][j]);
    printf("\n");
  }
}
// 函数调用
int x[M][N]={{1,2},{3,4},{5,6}};
fun(x,3,2);//调用时仅用数组名传递x的地址
\end{lstlisting}
%\end{beamerboxesrounded}
\end{columns}
~\\
\end{frame}

\begin{frame}[shrink,fragile]{函数调用时数据类型的隐式转换和显式转换}
\begin{lstlisting}
int a=2,b=3,c;

// pow函数原型: double pow(double x,double y);
// 编译器自动把实际参数a,b的int类型"隐式"转换为形式参数要求的double类型
// 计算$a^b$的结果是double类型, 赋值语句隐式转换为int, 但是会引起警告信息
c=pow(a,b);  

// 将函数的返回值强制转换为int, 不会有警告信息
c=(int)pow(a,b); 

// Visual Studio等编译器要求显式强制转换
c=(int)pow((double)a,(double)b); 

\end{lstlisting}
\end{frame}

\begin{frame}[shrink,fragile]{整数pow函数问题}
\vspace{-0.3cm}
\lstinline|double pow(double x,double y);| 数学库函数真对双精度浮点数设计。用它计算整数$x^y$会有复杂的精度问题, 因此整数运算尽量不要用此函数。 
\begin{lstlisting}
#include<stdio.h>
#include<math.h>   // 数学库函数
int main()
{
	int x=2,y=3;
	
	// 有些编译器会输出99,124, 因为转换前是99.999, 124.999 
	printf("%d,%d\n",(int)pow(10,x),(int)pow(5,y)); 
		
	return 0;
}
\end{lstlisting}
\end{frame}

\begin{frame}[shrink,fragile]{自定义整数pow函数}
\vspace{-0.5cm}
\begin{columns}[T]
\column{0.35\linewidth}
\begin{lstlisting}
#include<stdio.h>
// 自定义整数pow函数, 返回$x^y$
int intpow(int x, int y)
{
	int i,p=1;
	// 实现$0^y=0$
	if (x==0) return 0;
	
	for(i=0;i<y;i++) 
		p=p*x;
	
	return p;//包含了$0^0=1$
} 
\end{lstlisting}
\column{0.65\linewidth}
\begin{lstlisting}[frame=leftline]
int main()
{
	int x=2,y=3;
	
	printf("%d,%d\n",intpow(10,x),intpow(5,y)); 
	// 100,125
	printf("%d,%d\n",intpow(10,2),intpow(5,3)); 
	// 100,125
	printf("%d,%d\n",intpow(0,2),intpow(0,0)); 
	// 0,1 
	
	return 0;
}
\end{lstlisting}
\end{columns}
\end{frame}

\note{递归版
\begin{lstlisting}
int intpow(int x,int y)
{
	if(x==0 && y==0) return 1; // 这里规定: 0^0=1 
	// 递归 
	if(y==0) return 1; // x^0=1, 结束递归
	else if(y%2) return x*intpow(x,y/2)*intpow(x,y/2);
	return intpow(x,y/2)*intpow(x,y/2);
}
\end{lstlisting}
}


\section{程序举例}

\begin{frame}[shrink,fragile]{例: PM2.5}
给出一组PM2.5数据，按以下分级标准统计各级天气的天数，并计算出PM2.5平均值。

PM2.5分级标准为: 
一级优$(0\le PM2.5\le 50)$; 二级良$(51\le PM2.5\le 100)$;  三级轻度污染$(101\le PM2.5\le 150)$; 四级中度污染$(151\le PM2.5\le 200)$; 五级重度污染$(201\le PM2.5\le 300)$;六级严重污染$(PM2.5>300)$.

输入说明, 输入分为两行，

第一行是一个整数$n$表示天数$(1<n\le 100)$ 

第二行为$n$个非负整数$Pi(0\le Pi\le 1000)$表示每天的PM2.5值，整数之间用空格分隔。

输出说明, 输出两行数据，

第一行为PM2.5平均值, 结果保留2位小数; 

第二行依次输出一级优, 二级良, 三级轻度污染, 四级中度污染, 五级重度污染, 六级严重污染的天数。
\end{frame}

\begin{frame}[shrink,fragile]{例: PM2.5(非模块化设计)}
\vspace{-0.2cm}
\begin{tikzpicture}
\node[text width=0.65\textwidth,rounded corners,draw=none] (a) {
\vspace{-0.3cm}
\begin{lstlisting}
#include <stdio.h>
int main()
{
  int i =0,n,pm25,day[6] = {0,0,0,0,0,0},
  	  sum = 0;
  scanf("%d",&n);
  while(i < n) {
    scanf("%d",&pm25);
    sum += pm25;
    if(pm25 >= 0 && pm25 <= 50 ) day[0]++;
    else if(pm25 >= 51 && pm25 <= 100 ) day[1]++;
    else if(pm25 >= 101 && pm25 <= 150 ) day[2]++;
    else if(pm25 >= 151 && pm25 <= 200 ) day[3]++;
    else if(pm25 >= 201 && pm25 <= 300 ) day[4]++;
    else day[5]++;
    i++;
  } 
\end{lstlisting}
};
\node[anchor=north west,text width=0.55\textwidth,rounded corners,draw=none] at(a.north east) {
\vspace{-0.3cm}
\begin{lstlisting}
	printf("%.2f\n",(float)sum/n);
	for(i = 0; i < 6; i++)
		if(i == 5) printf("%d\n",day[i]);
		else  printf("%d ",day[i]);
	return 0;
}
\end{lstlisting}
};

\draw[dashed,red] (a.north east) -- (a.south east);
\end{tikzpicture}
\end{frame}

\begin{frame}[shrink,fragile]{例: PM2.5(模块化设计, 主程序)}
\vspace{-0.2cm}
\begin{tikzpicture}
\node[text width=0.5\textwidth,rounded corners,draw=none] (a) {
\vspace{-0.3cm}
\begin{lstlisting}
#include <stdio.h>
// 函数声明
float haze(int pm25[], int day[], int n, int m);
#define N 1000 // 估计的最大值
int main()
{
   int i =0,n,pm25[N],day[6];
   scanf("%d",&n);
   while(i < n) 
   {
     scanf("%d",&pm25[i]);
     i++;
   } 
} 
\end{lstlisting}
};
\node[anchor=north west,text width=0.55\textwidth,rounded corners,draw=none] at(a.north east) {
\vspace{-0.3cm}
\begin{lstlisting}
	 // 函数调用,并输出函数中计算的平均值
	printf("%.2f\n",haze(pm25,day,n,6));
	// 输出函数中计算的数组元素值
	for(i = 0; i < 6; i++)
		if(i == 5) printf("%d\n",day[i]);
		else  printf("%d ",day[i]);
	return 0;
}
\end{lstlisting}
};

\draw[dashed,red] (a.north east) -- (a.south east);
\end{tikzpicture}
\end{frame}

\begin{frame}[shrink,fragile]{例: PM2.5(模块化设计, 雾霾统计信息)}
\vspace{-0.4cm}
\begin{tikzpicture}
\node[text width=.8\textwidth] (a) {
\begin{lstlisting}
float haze(int pm25[], int day[], int n, int m)
{
  int i=0, sum=0;
  // 初始化day数组
  for(i=0; i<m; i++) day[i]=0;
  while(i < n) 
  {
    sum += pm25[i];
    if(pm25[i] >= 0 && pm25[i] <= 50 ) day[0]++;
    else if(pm25[i] >= 51 && pm25[i] <= 100 ) day[1]++;
    else if(pm25[i] >= 101 && pm25[i] <= 150 ) day[2]++;
    else if(pm25[i] >= 151 && pm25[i] <= 200 ) day[3]++;
    else if(pm25[i] >= 201 && pm25[i] <= 300 ) day[4]++;
    else day[5]++;
    i++;
  } 
  return (float)sum/n;
} 
\end{lstlisting}
};

\node[anchor=north west,text width=.5\textwidth] (b) at($(a.north east)+(-0.5,-1)$) {
	函数参数说明: pm25[]: PM2.5值, day[]: 不同标准对应的统计天数; n是pm25数组的长度, m是数组day的长度, 返回PM2.5平均值.
};

\node[anchor=north,text width=.5\textwidth,fill=green,rounded corners] at(b.south) {
	\textcolor{blue}{要点:}
	
	用数组做参数, 可获得函数计算结果的多值传递;
	
	而return仅返回一个值。
};
\end{tikzpicture}
\end{frame}

\begin{frame}[shrink,fragile]{例: 数字排序(主程序)}
给定n个整数，请计算每个整数各位数字和，按各位数字和从大到小的顺序输出。
\begin{lstlisting}
#include <stdio.h>
#define N 1000 // 估计的数组大小
int bitsSum(int a); // 计算整数a的各位之和
void sort(int a[], int n); // 从大到小排序
void output(int a[], int n); // 输出
int main()
{
   int i,n; // n是实际数组长度 
   int num[N],sum[N]; // num表示N个整数, sum存放对应整数的各位数字的和  
   scanf("%d",&n);
   for(i=0;i<n;i++) { scanf("%d",&num[i]);  sum[i]=bitsSum(num[i]); }
   sort(sum,n);  // 从大到小排序
   output(sum,n); // 输出
   return 0;
}
\end{lstlisting}
\end{frame}

\begin{frame}[shrink,fragile]{例: 数字排序(子函数: 计算整数的各位之和, 输出)}
%\centering
\begin{center}
\begin{tikzpicture}
\node[text width=0.35\textwidth] (a) {
\begin{lstlisting}
// 计算整数a的各位之和
int bitsSum(int a)
{
	int sum=0;
	while(a)
	{
		sum += a%10;
		a /= 10;
	}
	return sum;
}
\end{lstlisting}
};

\node[anchor=north west,text width=0.4\textwidth] (b) at(a.north east) {
\begin{lstlisting}
// 输出, n是数组长度
void output(int a[], int n)
{
	int i;
	for(i=0;i<n;i++) 
		printf("%d ",a[i]);
	printf("\n");
}
\end{lstlisting}
};

\draw[dashed,red] (a.north east) -- (a.south east);
\end{tikzpicture}
\end{center}
\end{frame}

\begin{frame}[shrink,fragile]{例: 数字排序(排序子函数---方法1: 冒泡排序)}
\vspace{-0.3cm}
\begin{lstlisting}
 void sort(int a[], int n) // 从大到小排序, 冒泡, n是数组长度
{
   int i,j,flag,temp;
   for(j = 1; j <= n-1; j++) // 第j趟比较
   {
      flag=0;
      for(i = 0; i < n - j; i++) // 相邻两数比较
      {
        if (a[i] < a[i+1]) // 交换
        { 
           temp = a[i]; a[i] = a[i+1]; a[i+1] = temp; 
           flag=1;
        }
      }
      if(!flag) break;
   }
}
\end{lstlisting}
\end{frame}

\begin{frame}[shrink,fragile]{选择法排序}
\begin{tikzpicture}[node distance=0.5cm, on grid,every label/.style={blue,outer sep=0pt,inner sep=2pt,align=center,font=\scriptsize}]
\node[text width=\textwidth] (a) {
	从大到小\textcolor{blue}{选择法排序}: 先将$n$个数中最大的数与$a[0]$对换, $a[0]$就是最大的数;
	
	再将$a[1]\sim a[n-1]$中最大的数与$a[1]$对换，$\cdots$, 每比较一轮,找出一个未经排序的数中最大的一个。共比较$n-1$轮。
	
	\begin{lstlisting}
	int a[]={5,8,2,9,3};  // 待排序的数
	int j,k; // j: 外层循环次数, 共$n-1$次, k: 每次循环选择的最大数下标
	\end{lstlisting}
};

\node[] at ($(a.south west)+(2,0)$) (aa) {$a[0]$};
\node[] (a1) [below= of aa] {$a[1]$};
\node[] (a2) [below= of a1] {$a[2]$};
\node[] (a3) [below= of a2] {$a[3]$};
\node[] (a4) [below= of a3] {$a[4]$};

%% j=0
\node[fill=green] (a0) [right=1cm of aa] {5};
\node[] (a1) [below= of a0] {8};
\node[] (a2) [below= of a1] {2};
\node[fill=red] (a3) [below= of a2] {9};
\node[] (a4) [below= of a3] {3};

\node[] (b0) [right=0.5cm of a0] {9};
\node[] (b1) [below= of b0] {8};
\node[] (b2) [below= of b1] {2};
\node[] (b3) [below= of b2] {5};
\node[] (b4) [below= of b3] {3};
\node[fit=(a0) (b4),label={south:$j=0,k=j$\\找出$k=3$\\交换$a[j],a[k]$},draw,dashed] {};

%% j=1
\node[] (a0) [right=1.5cm of b0] {9};
\node[fill=green] (a1) [below= of a0] {8};
\node[] (a2) [below= of a1] {2};
\node[] (a3) [below= of a2] {5};
\node[] (a4) [below= of a3] {3};

\node[] (b0) [right=0.5cm of a0] {9};
\node[] (b1) [below= of b0] {8};
\node[] (b2) [below= of b1] {2};
\node[] (b3) [below= of b2] {5};
\node[] (b4) [below= of b3] {3};
\node[fit=(a0) (b4),label={south:$j=1,k=j$\\找出$k=1$\\$k=j$无需交换},draw,dashed] {}; 

%% j=2
\node[] (a0) [right=1.5cm of b0] {9};
\node[] (a1) [below= of a0] {8};
\node[fill=green] (a2) [below= of a1] {2};
\node[fill=red] (a3) [below= of a2] {5};
\node[] (a4) [below= of a3] {3};

\node[] (b0) [right=0.5cm of a0] {9};
\node[] (b1) [below= of b0] {8};
\node[] (b2) [below= of b1] {5};
\node[] (b3) [below= of b2] {2};
\node[] (b4) [below= of b3] {3};
\node[fit=(a0) (b4),label={south:$j=2,k=j$\\找出$k=3$\\交换$a[j],a[k]$},draw,dashed] {};

%% j=3
\node[] (a0) [right=1.5cm of b0] {9};
\node[] (a1) [below= of a0] {8};
\node[] (a2) [below= of a1] {5};
\node[fill=green] (a3) [below= of a2] {2};
\node[fill=red] (a4) [below= of a3] {3};

\node[] (b0) [right=0.5cm of a0] {4};
\node[] (b1) [below= of b0] {3};
\node[] (b2) [below= of b1] {2};
\node[] (b3) [below= of b2] {1};
\node[] (b4) [below= of b3] {0};
\node[fit=(a0) (b4),label={south:$j=3,k=j$\\找出$k=4$\\交换$a[j],a[k]$},draw,dashed] {};
\end{tikzpicture}
\end{frame}

\note{
	\begin{lstlisting}
	下标     0 1 2 3 4
	j=0,k=j, 1 2 3 4 5==>max=5,k=4
	j=1,k=j, 5 2 3 4 1==>max=4,k=3
	j=2,k=j, 5 4 3 2 1==>max=3,k=2
	j=3,k=j, 5 4 3 2 1 break
	\end{lstlisting}
	
}

\begin{frame}[shrink,fragile]{例: 数字排序(排序子函数---方法2: 选择法排序)}
\vspace{-0.3cm}
\begin{lstlisting}
void sort(int a[], int n) // 从大到小排序, 选择
{
   int i,j,k,temp;
   for(j = 0; j <= n-2; j++) // 第j趟比较, 共n-1次循环
   {
     k=j; // 首先假设j就是未经排序的数中, 最大元素的下标
     for(i = j+1; i < n; i++) // 未经排序的数从j+1开始
     {
         if (a[i] > a[k]) k=i; // 如果第i个元素比第k个元素大, 置换k为i
     }
     if(k!=j)//未经排序数中的最大元素与a[j]交换, a[j]及其以前元素是已经排好的数据
     { 
        temp = a[j]; a[j] = a[k]; a[k] = temp; 
     }
   }
}
\end{lstlisting}
\end{frame}

\begin{frame}[shrink,fragile]{例: 数字排序(联动输出: 修改主程序)}
给定n个整数，请计算每个整数各位数字和，按各位数字和从大到小的顺序输出。

\textcolor{blue}{要求联动输出(整数跟随其数字和的排序次序输出): 整数\quad 该整数的各位之和}
\begin{lstlisting}
#include <stdio.h>
#define N 1000 // 估计的数组大小
int bitsSum(int a); // 计算整数a的各位之和
void sort(int a[], int b[], int n);  // a从大到小排序, b联动改变
void output(int a[], int b[], int n); // 输出a,b
int main()
{
   int i,n; // n是实际数组长度 
   int num[N],sum[N]; // num表示N个整数, sum存放对应整数的各位数字的和  
   scanf("%d",&n);
   for(i=0;i<n;i++) { scanf("%d",&num[i]); sum[i]=bitsSum(num[i]); }
   sort(sum,num,n);  // sum从大到小排序,num联动改变
   output(num,sum,n); // 输出num,sum
   return 0;
}
\end{lstlisting}
\end{frame}

\begin{frame}[shrink,fragile]{例: 数字排序(联动输出: 修改排序子函数)}
\vspace{-0.3cm}
\begin{lstlisting}
void sort(int a[], int b[],int n) // a从大到小排序, b联动改变
{
   int i,j,flag,temp;
   for(j = 1; j <= n-1; j++) // 第j趟比较
   {
       flag=0;
       for(i = 0; i < n - j; i++) // 相邻两数比较
       {
          if (a[i] < a[i+1]) // 同时交换a和b
          { 
             temp = a[i]; a[i] = a[i+1]; a[i+1] = temp; 
             temp = b[i]; b[i] = b[i+1]; b[i+1] = temp; 
             flag=1;
          }
       }
       if(!flag) break;
    }
}
\end{lstlisting}
\end{frame}

\begin{frame}[shrink,fragile]{例: 数字排序(联动输出: 修改输出子函数)}
\begin{lstlisting}
// 输出a,b
void output(int a[], int b[], int n)
{
   int i;
   for(i=0;i<n;i++) printf("%d %d",a[i],b[i]);
   printf("\n");
}
\end{lstlisting}
\end{frame}

\begin{frame}[shrink,fragile]{例: 数字排序(联动输出: 修改主程序,二维数组)}
\vspace{-0.2cm}
给定n个整数，请计算每个整数各位数字和，按各位数字和从大到小的顺序输出。

\textcolor{blue}{要求联动输出(整数跟随其数字和的排序次序输出): 整数\quad 该整数的各位之和}
\begin{lstlisting}
#include <stdio.h>
#define N 1000 // 估计的数组大小
int bitsSum(int a); // 计算整数a的各位之和
void sort(int a[][2], int n);  // a的第0列是整数, 第1列是其各位数字之和(排序列)
void output(int a[][2], int n); // 输出a, 第0列是整数, 第1列是其各位数字之和
int main()
{
   int i,n; // n是实际数组长度 
   int num[N][2]; // 第0列表示整数, 第1列是其各位数字的和  
   scanf("%d",&n);
   for(i=0;i<n;i++) 
   { scanf("%d",&num[i][0]); num[i][1]=bitsSum(num[i][0]); }
   sort(num,n);  // sum从大到小排序,num联动改变
   output(num,n); // 输出num
   return 0;
}
\end{lstlisting}
\end{frame}

\begin{frame}[shrink,fragile]{例: 数字排序(联动输出: 修改排序子函数,二维数组)}
\vspace{-0.3cm}
\begin{lstlisting}
void sort(int a[][2],int n) // a的第0列是整数, 第1列是其各位数字之和(排序列)
{
   int i,j,flag,temp;
   for(j = 1; j <= n-1; j++) // 第j趟比较
   {
      flag=0;
      for(i = 0; i < n - j; i++) // 相邻两数比较
      {
          if (a[i][1] < a[i+1][1]) // 同时交换a的第0列和第1列
          { 
            temp = a[i][0]; a[i][0] = a[i+1]; a[i+1][0] = temp; 
            temp = a[i][1]; a[i][1] = a[i+1][1]; b[i+1][1] = temp; 
            flag=1;
          }
      }
      if(!flag) break;
   }
}
\end{lstlisting}
\end{frame}

\begin{frame}[shrink,fragile]{例: 数字排序(联动输出: 修改输出子函数, 二维数组)}
\begin{lstlisting}
// 输出, a的第0列是整数, 第1列是其各位数字之和(排序列)
void output(int a[][2], int n)
{
   int i;
   for(i=0;i<n;i++) printf("%d %d",a[i][0],a[i][1]);
   printf("\n");
}
\end{lstlisting}

\begin{block}{模块化程序设计的优点}
	综上，程序功能的变化，仅修改相应子函数即可, 逻辑清晰。\\
	因此，利用函数进行功能分解是进行复杂程序设计的有效手段。
\end{block}
\end{frame}






