%%%%%%%%%%%%%%%%%%%%% chapter.tex %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% sample chapter
%
% Use this file as a template for your own input.
%
%%%%%%%%%%%%%%%%%%%%%%%% Springer-Verlag %%%%%%%%%%%%%%%%%%%%%%%%%%
%\motto{Use the template \emph{chapter.tex} to style the various elements of your chapter content.}
\chapter{第5次机试练习:  继续练习流程控制, 简单数组应用}

\section{最小差值}
给定n个数，请找出其中相差（差的绝对值）最小的两个数，输出它们的差值的绝对值。

输入格式

输入第一行包含一个整数n。

第二行包含n个正整数，相邻整数之间使用一个空格分隔。

输出格式

输出一个整数，表示答案。

样例输入

5

1 5 4 8 20

样例输出

1

样例说明

相差最小的两个数是5和4，它们之间的差值是1。

样例输入

5

9 3 6 1 3

样例输出

0

样例说明

有两个相同的数3，它们之间的差值是0.

数据规模和约定

对于所有评测用例，$2\le n\le1000$，每个给定的整数都是不超过10000的正整数。

\begin{lstlisting}
#include <stdio.h>
#include <math.h>
#define N 10000 // 估计数组num的最大长度 
int main()
{
	int i,j,n,num[N],smallest,temp; 
	scanf("%d",&n);
	// 输入数组各元素
	for(i=0;i<n;i++) // 实际数组的最大长度n, 下标由0到(n-1)
	{
		scanf("%d",&num[i]);
	}
	// 初始的最小值就是前两个数的差值, 注意初始化值必须是实际存在的值，而不能想当然给值。
	smallest=(int)fabs(num[0]-num[1]); // 整数绝对值函数int abs(int x)在低版本编译器中有问题, 此处用双精度绝对值函数代替, 其结果转换为整数。  
	
	// 前后两项比较
	for(i=0;i<=n-2;i++) // 循环变量i用于访问数组元素, 注意数组边界问题
	{
		for(j=i+1;j<n;j++)
		{
			temp=(int)fabs(num[i]-num[j]);
			if(smallest>temp) smallest=temp;
		}
	}
	printf("%d\n",smallest);
	return 0;
} 
\end{lstlisting}

\begin{note}[整数求绝对值函数]
	\lstinline|int abs(int x);| 在有些低版本编译器中，\lstinline|math.h|头文件无此函数原型说明，可用\lstinline|double fabs(double x);|代替。见本例。
\end{note}

\section{PM2.5}
给出一组PM2.5数据，按以下分级标准统计各级天气的天数，并计算出PM2.5平均值。
PM2.5分级标准为:\\
一级优(0<=PM2.5<=50)\\
二级良(1<=PM2.5<=100)\\
三级轻度污染(101<=PM2.5<=150)\\
四级中度污染(151<=PM2.5<=200)\\
五级重度污染(201<=PM2.5<=300)\\
六级严重污染(PM2.5>300)\\

输入说明
	
输入分为两行，

第一行是一个整数n表示天数（1<n<=100）；

第二行为n个非负整数Pi（0<=Pi<=1000），表示每天的PM2.5值，整数之间用空格分隔。

输出说明
	
输出两行数据，

第一行为PM2.5平均值，结果保留2位小数；

第二行依次输出一级优，二级良，三级轻度污染，四级中度污染，五级重度污染，六级严重污染的天数。

输入样例
	
10

50 100 120 80 200 350 400 220 180 165

输出样例	

186.50

1 2 1 3 1 2

\begin{lstlisting}
#include <stdio.h>

int main()
{
	// 用数组变量day存储数据，避免设置6个变量存储。
	int i =0,n,pm25,day[6] = {0,0,0,0,0,0},sum = 0;
	scanf("%d",&n);
	while(i < n) 
	{
		scanf("%d",&pm25);
		sum += pm25;
		if(pm25 >= 0 && pm25 <= 50 ) day[0]++;
		else if(pm25 >= 51 && pm25 <= 100 ) day[1]++;
		else if(pm25 >= 101 && pm25 <= 150 ) day[2]++;
		else if(pm25 >= 151 && pm25 <= 200 ) day[3]++;
		else if(pm25 >= 201 && pm25 <= 300 ) day[4]++;
		else day[5]++;
		i++;
	} 
	printf("%.2f\n",(float)sum/n);
	for(i = 0; i < 6; i++)  // 视作一条语句, 省略{ }
		if(i == 5) printf("%d\n",day[i]);
		else  printf("%d ",day[i]);
	
	return 0;
} 
\end{lstlisting}

\begin{note}[要点]
	\lstinline|if() { } else if() { } else { }|的用法, 循环语句的\{ \}.
	
	体会数组变量day的使用, 避免变量过多，难于管理的麻烦。
\end{note}

\section{折点计数}	
给定n个整数表示一个商店连续n天的销售量。如果某天之前销售量在增长，而后一天销售量减少，则称这一天为折点，反过来如果之前销售量减少而后一天销售量增长，也称这一天为折点，其他的天都不是折点。如图所示，第3天和第6天是折点。

\includegraphics*[scale=0.7]{points}

给定n个整数a1, a2, \dots, an表示连续n天中每天的销售量。请计算出这些天总共有多少个折点。

输入说明
	
输入的第一行包含一个整数n。

第二行包含n个整数，用空格分隔，分别表示$a_1, a_2, \dots, a_n$。

$3\le n\le 100$，每天的销售量是不超过1000的非负整数。为了减少歧义，输入数据保证：在这n天中相邻两天的销售量总是不同的，即$a_{i-1}\ne a_i$。

输出说明	

输出一个整数，表示折点数量。

输入样例	

7

5 4 1 2 3 6 4

输出样例
	
2

\begin{lstlisting}
#include <stdio.h>
// 解法一, 使用标志变量up, 判断是否后一数据大于前一数据.
int main()
{
    // 估计数组a的实际长度为100, 实际长度是n(待输入的值)
	int i = 0, points = 0, n = 7, a[100] = {5,4,1,2,3,6,4}; // 把样例数据作为初始化，方便调试
	int up; // 标志变量 
	
	// 有了初始化数据，这些输入语句在调试时就可注释掉，达到快速调试程序逻辑的目的。
	scanf("%d",&n); // 输入数组a的实际长度
	// 输入各元数值
	for(i = 0; i < n; i++) scanf("%d",&a[i]);
	
	// 标志变量up的初始值必须是真实存在的值，不要想当然。
	up = a[1] > a[0] ? 1 : -1; // 如果a[1] > a[0]成立, up=1,否则up=-1
	for(i = 2; i < n; i++)
	{
		if((a[i] > a[i-1] && up < 0) || (a[i] < a[i-1] && up > 0))
			points++;
		up = a[i] > a[i-1] ? 1 : -1;
	}
	
	printf("%d\n",points);
	return 0;
} 

// 解法二, 通过判断a[i]前后相邻两数据, 确定是否折点. 
int main()
{
	// 估计数组a的实际长度为100, 实际长度是n(待输入的值)
	int i = 0, points = 0, n = 7, a[100] = {5,4,1,2,3,6,4}; // 把样例数据作为初始化，方便调试
	scanf("%d",&n);
	for(i=0;i<n;i++) scanf("%d",&a[i]);
	
	for(i=1;i<n-1;i++) // 注意数组边界，不要越界。 
	{
		if((a[i]<a[i-1] && a[i]<a[i+1]) || (a[i]>a[i-1] && a[i]>a[i+1]))
			points++;
	}
	printf("%d\n",points);
	return 0;
}
\end{lstlisting}

\begin{note}[要点]
	善用标志变量, 标志变量的初始值必须是真实存在的值，不要想当然。
	
	样例数据作为初始化数据，调试时注释掉输入语句，便于进行快速调试程序。
\end{note}

\section{寻找最大整数}
从键盘输入四个整数，找出其中的最大值并将其输出。

输入说明

输入4个整数，用空格分隔

输出说明

输出值最大的一个整数

输入样例

25 99 -46 0

输出样例

99

\begin{lstlisting}
#include <stdio.h>
// 不用存储整数序列, 采用一条循环语句，合并输入和计算，减少出错概率。 
int main() 
{
	int i, num, max;
	// 输入, 并计算 
	for(i = 0; i < 4; i++) 
	{ 
		if (i==0) scanf("%d",&max); // 假定第一个数就是最大的数 
		else
		{
			scanf("%d",&num);
			if(num > max) max=num; 
		} 
	} 
	printf("%d\n",max);
	return 0;
} 

int main1() // 另解, 存储整数序列
{
	int i, num[4], max;
	// 输入 
	for(i = 0; i < 4; i++) 
		scanf("%d",&num[i]);
	// 假定的最大值必须是实际存在的，不要想当然是0,9999,等等。
	max = num[0]; 
	for(i = 0; i < 4; i++)  
		if(max < num[i]) max = num[i];
	
	printf("%d\n",max);
	return 0;
} 
\end{lstlisting}

\begin{note}[要点]
	题目虽然简单，你能体会哪种解法更好? 特别注意假定变量的值必须是实际存在的数。
\end{note}

\section{查找}	
给定一个包含$n$个整数的数列$A_0, A_1, A_2, \dots, A_{n-1}$和一个整数$k$，依次输出$k$在序列中出现的位置(从0开始计算)。

输入说明	

输入由两行构成，第一行为两个整数$n$和$k$，分别表示数列中整数个数和待查找整数$k,n$和$k$之间用空格分隔，$0<n<100，0<k<10000$。

第二行为$n$个整数，表示数列中的各个整数，整数之间用空格分隔，每个整数均不超过10000。

输出说明	

依次输出整数k在数列中出现的位置（从0开始计算），如果k未在数列中出现，则输出-1。

输入样例

样例1输入
	
5 20

10 20 30 20 5

样例2输入

5 20

10 30 25 34 44

输出样例
	
样例1输出

1 3

样例2输出

-1

\begin{lstlisting}
# include <stdio.h>
#define N 100
int main()
{
	// N是估计数组a的最大长度，实际长度是n; 标志变量flag表示是否k在a数组中
	int a[N],n,i,k,flag=0; 
	scanf("%d%d",&n,&k);
	for(i=0;i<n;i++)
	{
		scanf("%d",&a[i]);
		if(k==a[i]) 
		{
			printf("%d ",i);
			flag=1;
		}
	} 
	if(flag) printf("\n");
	else printf("-1\n");
	return 0;
}
\end{lstlisting}

\begin{note}[要点]
	简单处理，不要复杂化。
\end{note}

\section{中间数}
在一个整数序列$A_1, A_2,\dots, A_n$中，如果存在某个数，大于它的整数数量等于小于它的整数数量，则称其为中间数。

在一个序列中，可能存在多个下标不相同的中间数，这些中间数的值是相同的。 

给定一个整数序列，请找出这个整数序列的中间数的值。 

输入说明

输入的第一行包含了一个整数n，表示整数序列中数的个数，$1\le n\le 1000$。
 
第二行包含$n$个正整数，依次表示$A_1, A_2, \dots, A_n,~1\le A_i\le 1000$。 

输出说明

如果序列的中间数存在，则输出中间数的值，否则输出-1表示不存在中间数。

输入样例

输入样例1 

6 

2 6 5 6 3 5 

输入样例2 

4 

3 4 6 7 

输出样例

输出样例1 

5 

输出样例2 

-1

提示信息

样例1中比5小的数有2个，比5大的数也有2个。因此中间数是5 

样例2中4个数都不满足中间数的定义，因此中间数是-1

\begin{lstlisting}
#include <stdio.h>
int main()
{
	int n, a[1000];
	int i,j,larger,smaller;	// larger,smaller: 比a[i]大或小的数计数
	scanf("%d",&n);
	for(i = 0; i < n; i++) scanf("%d",&a[i]);
	
	for(i = 0; i < n; i++)
	{
		larger = smaller = 0;
		for(j = 0; j < n; j++)
		{
			if(a[j] >= a[i]) larger++; 
			if(a[j] <= a[i]) smaller++;
		}
		if(larger != 0 && larger == smaller) 
		{
			printf("%d ",a[i]); 
			break;  // 最多有一个中间数，其它将与此同值。 
		}
	}
	if(i == n) printf("-1\n"); // 没有中间数 
	return 0;
}
\end{lstlisting}

\begin{note}[要点]
	训练自己的逻辑思维能力。
\end{note}



