%%%%%%%%%%%%%%%%%%%%% chapter.tex %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% sample chapter
%
% Use this file as a template for your own input.
%
%%%%%%%%%%%%%%%%%%%%%%%% Springer-Verlag %%%%%%%%%%%%%%%%%%%%%%%%%%
%\motto{Use the template \emph{chapter.tex} to style the various elements of your chapter content.}
\chapter{第9次机试练习: 结构体}

\section{复试筛选}	
考研初试成绩公布后需要对m个学生的成绩进行排序，筛选出可以进入复试的前n名学生。
排序规则为首先按照总分排序，总分相同则按英语单科成绩排序，总分和英语成绩也相同时考号小者排在前面。

现给出这m个学生的考研初试成绩，请筛选出可以进入复试的n名学生并按照排名从高到低的顺序依次输出。

输入说明	

输入为m+1行，第一行为两个整数m和n，分别表示总人数和可以进入复试人数，m和n之间用空格分隔，0<n<m<200。

接下来为m行数据，每行包括三项信息，分别表示一个学生的考号(长度不超过20的字符串)、总成绩(小于500的整数)和英语单科成绩(小于100的整数), 这三项之间用空格分隔。

输出说明

按排名从高到低的顺序输出进入复试的这n名学生的信息。

输入样例	

5 3

XD20160001 330 65

XD20160002 330 70

XD20160003 340 60

XD20160004 310 80

XD20160005 360 75

输出样例	

XD20160005 360 75

XD20160003 340 60

XD20160002 330 70

\begin{lstlisting}
// 思路：定义结构体类型和结构体数组，对结构体数组进行排序。 
#include <stdio.h>
#include <string.h>

// 估计结构体数组最大长度 
#define N 200

struct Student 
{
	char no[20];   // 考号 
	int  total;    // 总成绩 
	int  english;  // 英语成绩  
};

// 输入m个考生信息
void input(struct Student *stus, int m)
{
	int i;
	for(i=0;i < m;i++) 
		scanf("%s%d%d",	stus[i].no,&stus[i].total,&stus[i].english); 
}

// 输入n个考生信息
void print(struct Student *stus, int n)
{
	int i;
	for(i=0;i<n;i++) 
		printf("%s %d %d\n",stus[i].no,stus[i].total,stus[i].english); 
}

// 交换两个结构体对象 
void swap(struct Student *p1, struct Student *p2)
{
	struct Student temp;
	temp = *p1; *p1 = *p2; *p2 = temp;
}

/************************************************* 
 选择法排序（降序）
 排序规则为首先按照总分排序，总分相同则按英语单科成绩排序
**************************************************/ 
void sorts(struct Student a[], int n)
{
	int i,j,k;
	for(i = 0; i < n - 1; i++)
	{
		k = i;
		for (j = i+1; j < n; j++)
		{
			// 条件判断语句：善用&&、||运算，简化if else结构 
			// 注意(条件1||条件2||$\cdots$)的截断语义
			if (a[j].total>a[k].total || (a[j].total==a[k].total &&  a[j].english>a[k].english)
			|| (a[j].total==a[k].total &&  a[j].english==a[k].english && strcmp(a[j].no,a[k].no)<0))  
			k = j;
		}
		if (k != i) swap(&a[i],&a[k]);
	} 
}

int main()
{
	struct Student stus[N]; 
	int m,n,i;
	scanf("%d%d",&m,&n);
	input(stus,m); 
	sorts(stus,m);
	print(stus,n);
	return 0;
}
\end{lstlisting}

\begin{note}[要点]
	\begin{itemize}
		\item 条件判断语句：善用 \lstinline$&&, ||$ 运算，简化\lstinline|if else|结构
		\item \lstinline!if (条件1||条件2||条件3||$\cdots$)!, 从左到右计算条件表达式, 如果任一条件为\lstinline|true|, 不必进行后续条件的判断。称为``或''条件的截断语义。
		\item 本例是结构体数组排序, 模块化程序设计的典型案例,  详见课件。 
	\end{itemize}
\end{note}

\section{画图}
在一个定义了直角坐标系的纸上，画一个(x1,y1)到(x2,y2)的矩形，指将横坐标范围从x1到x2，纵坐标范围从y1到y2之间的区域涂上颜色。    
下图给出了一个画了两个矩形的例子。第一个矩形是(1,1) 到(4, 4)，用绿色和紫色表示。第二个矩形是(2, 3)到(6, 5)，用蓝色和紫色表示。

\begin{center}
	\includegraphics*[scale=0.4]{paint}
\end{center}

图中，一共有15个单位的面积被涂上颜色，其中紫色部分被涂了两次，但在计算面积时只计算一次。在实际的涂色过程中，所有的矩形 都涂成统一的颜色，图中显示不同颜色仅为说明方便。给出所有要画的矩形，请问总共有多少个单位的面积被涂上颜色。

输入说明 

输入的第一行包含一个整数n，表示要画的矩形的个数，1<=n<=100   

接下来n行，每行4个非负整数，分别表示要画的矩形的左下角的横坐标与纵坐标，以及右上角的横坐标与纵坐标。0<=横坐标、纵坐标<=100。

输出说明	

输出一个整数，表示有多少个单位的面积被涂上颜色。

输入样例

2 

1 1 4 4 

2 3 6 5 

输出样例

15

\begin{lstlisting}
#define N 100
//定义矩形结构体 
struct Rec
{
	int leftBottomX;
	int leftBottomY;
	int rightTopX;
	int rightTopY;
};

// 返回最大矩形
struct Rec Largest(struct Rec res[], int n)
{
	struct Rec largest=res[0];
	int i;
	for(i=1;i<n;i++)
	{
		if(res[i].leftBottomX < largest.leftBottomX) largest.leftBottomX=res[i].leftBottomX;
		if(res[i].leftBottomY < largest.leftBottomY) largest.leftBottomY=res[i].leftBottomY;
		if(res[i].rightTopX > largest.rightTopX) largest.rightTopX=res[i].rightTopX;
		if(res[i].rightTopY > largest.rightTopY) largest.rightTopY=res[i].rightTopY;
	}
	return largest; 
} 

// rec区域, grid数组元素置1 
void grid1(struct Rec rec, int grid[][N])
{
	int i,j;
	for(i=rec.leftBottomY;i<rec.rightTopY;i++)
	{
		for(j=rec.leftBottomX;j<rec.rightTopX;j++)
			grid[i][j]=1;
	} 
}

// largest区域, grid数组元素初始化为0 
void grid0(struct Rec largest, int grid[][N])
{
	int i,j;
	for(i=largest.leftBottomY;i<largest.rightTopY;i++)
	{
		for(j=largest.leftBottomX;j<largest.rightTopX;j++)
			grid[i][j]=0;
	} 
}

// largest区域, 返回grid数组元素为1的单元数量，即被覆盖的单位面积数 
int gridNum(struct Rec largest, int grid[][N])
{
	int i,j,num=0;
	for(i=largest.leftBottomY;i<largest.rightTopY;i++)
	{
		for(j=largest.leftBottomX;j<largest.rightTopX;j++)
			if(grid[i][j]) num++;
	} 
	return num;
}

void input(struct Rec *recs, int n)
{
	int i;
	for(i=0;i<n;i++) 
		scanf("%d%d%d%d",&recs[i].leftBottomX,&recs[i].leftBottomY,
	&recs[i].rightTopX,&recs[i].rightTopY);
} 

void print(struct Rec *recs, int n)
{
	int i;
	for(i=0;i<n;i++) 
		printf("%d,%d,%d,%d\n",recs[i].leftBottomX,recs[i].leftBottomY,
	recs[i].rightTopX,recs[i].rightTopY);
} 

int main()
{
	int grid[N][N],n,i,num;
	struct Rec recs[N],largest;
	scanf("%d",&n);
	input(recs,n);
	// print(recs,n); // 检查输入 
	largest=Largest(recs,n); // 计算最大矩形 
	// print(&largest,1); // 查看最大矩形是否正确 
	grid0(largest,grid); // 初始化 
	for(i=0;i<n;i++)
	{
		grid1(recs[i],grid); // 置1 
	}
	printf("%d\n",gridNum(largest,grid)); // 统计输出 
	return 0;
}
\end{lstlisting}

\begin{note}[要点]
详见课件。注意使用标志矩阵表示最大矩阵的使用技巧。 进一步练习模块化程序设计方法。
\end{note}


