%%%%%%%%%%%%%%%%%%%%% chapter.tex %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% sample chapter
%
% Use this file as a template for your own input.
%
%%%%%%%%%%%%%%%%%%%%%%%% Springer-Verlag %%%%%%%%%%%%%%%%%%%%%%%%%%
%\motto{Use the template \emph{chapter.tex} to style the various elements of your chapter content.}
\chapter{第6次机试练习: 数组,排序,字符串练习}

\section{ISBN号码}
每一本正式出版的图书都有一个ISBN号码与之对应，ISBN码包括9位数字、1位识别码和3位分隔符，其规定格式如"x-xxx-xxxxx-x"，
其中符号“-”是分隔符（键盘上的减号），最后一位是识别码，例如0-670-82162-4就是一个标准的ISBN码。

ISBN码的首位数字表示书籍的出版语言，例如0代表英语；

第一个分隔符“-”之后的三位数字代表出版社，例如670代表维京出版社；

第二个分隔之后的五位数字代表该书在出版社的编号；

最后一位为识别码。识别码的计算方法如下：

首位数字乘以1加上次位数字乘以2……以此类推，用所得的结果mod 11，所得的余数即为识别码，如果余数为10，则识别码为大写字母X。
例如ISBN号码0-670-82162-4中的识别码4是这样得到的：
对067082162这9个数字，从左至右，分别乘以1，2，\dots，9，再求和，即$0\times 1+6\times 2+\dots +2\times 9=158$，然后取158 mod 11的结果4作为识别码。

编写程序判断输入的ISBN号码中识别码是否正确，如果正确，则仅输出``Right"; 如果错误，则输出正确的ISBN号码。

输入说明	

输入只有一行，是一个字符序列，表示一本书的ISBN号码(保证输入符合ISBN号码的格式要求)。

输出说明	

输出一行，假如输入的ISBN号码的识别码正确，那么输出``Right"，否则，按照规定的格式，输出正确的ISBN号码(包括分隔符``-")。

输入样例	

样例输入1

0-670-82162-4

样例输入2

0-670-82162-0

输出样例	

样例输出1

Right

样例输出2

0-670-82162-4

\begin{lstlisting}
#include <stdio.h>
int main()
{
	// 按题意, 存储ISBN需要13个字符, 再加上字符串结束字符'\0'.
	// 样例数据作为初始化，方便调试
	char ISBN[14] = "0-670-82162-4";  // ISBN[13]='\0'
	//char ISBN[14] = "0-670-82162-0";  
	int i,j,sum=0,r; // r=sum % 11 
	
	// 调试时，注释输入语句 
	// 末尾自动添加'\0'.
	scanf("%s",ISBN);  // 或 gets(ISBN);
	
	// 对识别码之前的数字求和, 注意边界.
	for(i = 0,j = 1; i < 11; i++)
	{
		if (ISBN[i]=='-') continue;
		sum += (ISBN[i]-'0')*j;   // 整数与单个数字字符的关系：9 = '9' -'0' 
		j++;
	}   
	
	r=sum%11;
	
	// 特别处理识别码 ISBN[12]
	if (r==10)
	{
		if(ISBN[12]=='X') printf("Right\n");
		else 
		{
			ISBN[12]='X';
			printf("%s\n",ISBN); // 或 puts(ISBN);
		}
	}
	else
	{
		// 数字转字符 r+'0'
		if(ISBN[12]== r +'0') printf("Right\n");
		else 
		{
			ISBN[12]= r +'0';
			printf("%s\n",ISBN); // 或 puts(ISBN);
		}
	} 

	return 0;
} 
\end{lstlisting}

\begin{note}[要点]
\begin{enumerate}
\item 仔细审题, 考虑输入的识别码, 可能是'X'的情况.
\item 定义字符数组表示字符串时，且记给\lstinline|'\0'|留一个字符的位置, 表示字符串的结尾。
\item \lstinline|ASCII编码(整数)=字符-'0';|
\item \lstinline|字符=ASCII编码(整数)+'0';|
\item 整数可以表示字符的ASCII编码(整数), 整数和字符类型可以``混用", 详见课件。
\begin{lstlisting}
int a; char c='A';
a = c+1; // c当作整数运算
printf("%d %c %d %c\n",a,a,c,c); //66 B 65 A 
\end{lstlisting}
\end{enumerate}
\end{note}

\section{密码强度}
每个人都有很多密码，你知道你的密码强度吗？假定密码由大写字母、小写字母、数字和非字母数字的符号这四类字符构成，密码强度计算规则如下：

1.	基础分：空密码(密码长度为零)0分, 非空密码1分

2.	加分项1：密码长度超过8位, +1分

3.	加分项2：密码包含两类不同字符+1分, 包含三类不同字符+2分, 包含四类不同字符+3分

按照此规则计算的密码强度为$0\sim 5$。请你设计一个程序计算给出的密码的强度。

输入说明

输入为一个密码字符串，字符串长度不超过50个字符。

输出说明

输出一个整数表示该密码的强度。

输入样例

输入样例1

abcd

输入样例2

ab123

输出样例

样例1输出：

1

样例2输出

2

\begin{lstlisting}	
#include <stdio.h>
#include <string.h>
int main()
{
	char p[51]; // 记得给'\0'留位置
	int i,strength = 0;
	// class4[0]=1大写字母， class4[1]=1小写字母, class4[2]=1数字， class4[3]=1非字母数字 
	int class4[4] = {0,0,0,0};  
	
	//scanf("%s",p);  // 不能完整接收含空格的字符串和空密码 
	gets(p); // last char: '\0'，直接回车，就是空密码 
	
	// 	1.	基础分：空密码(密码长度为零)0分，非空密码1分 
	if(strlen(p) == 0) strength += 0;
	else  strength += 1;
	
	// 2.	加分项1：密码长度超过8位，+1分 
	if(strlen(p) > 8) strength += 1;
	
	// 3.	加分项2：密码包含两类不同字符+1分，包含三类不同字符+2分，包含四类不同字符+3分 
	for(i = 0; p[i] != '\0'; i++)
	{
		if(p[i] >= 'A' && p[i] <= 'Z') class4[0] = 1; 
		else if(p[i] >= 'a' && p[i] <= 'z') class4[1] = 1; 
		else if(p[i] >= '0' && p[i] <= '9') class4[2] = 1;
		else class4[3] = 1; 
	}
	int c = 0;
	for(i = 0; i < 4; i++) c += class4[i];
	
	if(c >= 4) strength += 3;
	else if(c >= 3) strength += 2;
	else if(c >= 2) strength += 1;
	
	printf("%d\n",strength);
	
	return 0;
}
\end{lstlisting}

\begin{note}[要点]
	字符串处理的典型问题: \lstinline|'\0'|, 字符串相关函数\lstinline|char s1[81],s2[81]; strlen(s1), strcmp(s1,s2), strcpy(s1,s2); scanf("%s",s1), gets(s1)|的区别等, 应该充分掌握。
\end{note}

\section{排序}	
给定N个不同的整数，要求对这N个整数按如下规则排序并输出。

规则一：所有的偶数排在奇数前面。

规则二：在规则一的前提下按照从大到小的顺序排序。

输入说明	

数据由两行构成，第一行为整数n (n<=100), 表示待排序整数的数量。第二行是n个整数，每个整数的取值区间都为$[-32768\sim32767]$，整数之间以空格间隔。

输出说明
	
在一行输出排好序的整数，整数之间以空格间隔。

输入样例	

5 

1 2 3 4 5

输出样例
	
4 2 5 3 1

\begin{lstlisting}
# include <stdio.h>
#define N 100

// 选择法从大到小排序 
int sorts(int a[],int n)
{
	int i,j,k,tmp;
	for(i=0;i<n-1;i++)
	{
		k=i; // 未排序中较大者 
		for(j=i+1;j<n;j++)
		if(a[j]>a[k]) k=j;
		if(k!=i)
		{
			tmp=a[i];
			a[i]=a[k];
			a[k]=tmp;
		} 
	}
}

int main()
{
	int even[N],odd[N],n,i,num;
	int evenN=0, oddN=0;
	scanf("%d",&n);
	for(i=0;i<n;i++)
	{
		scanf("%d",&num);
		if(num%2==0) // even
		{
			even[evenN]=num;
			evenN++;
		}
		else
		{
			odd[oddN]=num;
			oddN++;
		}
	} 
	// 排序
	sorts(even,evenN);
	sorts(odd,oddN);
	// 输出 
	for(i=0;i<evenN;i++) printf("%d ",even[i]); 
	for(i=0;i<oddN;i++) printf("%d ",odd[i]); 
	printf("\n"); 
	return 0;
}
\end{lstlisting}

\begin{note}[要点]
	各种形式的排序问题(整数, 字符, 字符串, 结构体)是必须掌握的重点之一。选择法排序或冒泡法排序必须信手拈来。
\end{note}

\section{等差数列}	
请写一个程序，判断给定整数序列能否构成一个等差数列。

输入说明
	
输入数据由两行构成，第一行只有一个整数n(n<100), 表示序列长度(该序列中整数的个数);

第二行为n个整数，每个整数的取值区间都为$[-32768\sim 32767]$, 整数之间以空格间隔。

输出说明	

对输入数据进行判断，不能构成等差数列输出``no", 能构成等差数列输出表示数列公差(相邻两项的差)的绝对值的一个整数。

输入样例
	
样例1输入

6

23 15 4 18 35 11

样例2输入

5

2 6 8 4 10

输出样例
	
样例1输出

no

样例2输出

2

\begin{lstlisting}
# include <stdio.h>
#define N 100

// 选择法从大到小排序 
int sorts(int a[],int n)
{
	int i,j,k,tmp;
	for(i=0;i<n-1;i++)
	{
		k=i; // 未排序中较大者 
		for(j=i+1;j<n;j++)
		if(a[j]>a[k]) k=j;
		if(k!=i)
		{
			tmp=a[i];
			a[i]=a[k];
			a[k]=tmp;
		} 
	}
}

// 排序后的a是否构成等差数列，是返回1，否则返回0
// 若是等差数列, 指针参数tolerance返回公差的绝对值。 
int check(int a[],int n, int *tolerance)
{
	int i;
	*tolerance = a[0]-a[1]; // 大-小，不用求绝对值 
	for(i=1;i<n-1;i++) // 注意检查数组越界问题
	{
		if(a[i]-a[i+1] != *tolerance) return 0;
	} 
	return 1;
}

int main()
{
	int a[N],n,i,tolerance;
	scanf("%d",&n);
	for(i=0;i<n;i++)
	{
		scanf("%d",&a[i]);
	} 
	// 排序
	sorts(a,n);
	// check
	if(check(a,n, &tolerance)) printf("%d\n",tolerance);
	else printf("no\n");
	return 0;
}
\end{lstlisting}

\begin{note}[要点]
	数组越界问题, 排序, 地址传递, 模块化程序设计。
\end{note}

\section{0-1矩阵}	
查找一个只包含0和1的矩阵中每行最长的连续1序列。

输入说明
	
输入第一行为两个整数m和n (0<=m,n<=100)表示二维数组行数和列数，其后为m行数据，每行n个整数(0或1), 输入数据中不会出现同一行有两个最长1序列的情况。

输出说明
	
找出每一行最长的连续1序列，输出其起始位置(从0开始计算)和结束位置(从0开始计算)，如果这一行没有1则输出两个-1,然后换行。

输入样例 
	
5 6

1 0 0 1 1 0

0 0 0 0 0 0

1 1 1 1 1 1

1 1 1 0 1 1

0 0 1 1 0 0

输出样例
	
3 4

-1 -1

0 5

0 2

2 3

\begin{lstlisting}
#include <stdio.h>
#define N 100

int main()
{
	// 标志变量start,end, maxLen: 记录本行最长连续1总体情况
	// 标志变量tmpStart, tmpLen: 标志是否开始连续1及连续长度 
	int a[N][N],m,n,i,j,start,end,tmpStart,maxLen,tmpLen;
	scanf("%d%d",&m,&n);
	for(i=0;i<m;i++)
		for(j=0;j<n;j++)
			scanf("%d",&a[i][j]);
	
	// 遍历各行		
	for(i=0;i<m;i++) // 行
	{
		start=-1; end=-1; maxLen=0; // 本行连续1总体情况
		tmpStart=-1; tmpLen=0; // 标志是否开始连续1及连续长度
		for(j=0;j<n;j++) // 列
		{
			if(a[i][j]==1) // 1开始 
			{
				if (tmpStart==-1) tmpStart=j; // 开始记录 
				tmpLen++;
			}
			else // 遇0结算 
			{
				if(tmpStart!=-1 && tmpLen>maxLen) 
				{
					start=tmpStart;
					end=j-1;
					maxLen=tmpLen;
					tmpStart=-1;
					tmpLen=0;
				}
			}
		}
		if(tmpStart!=-1 && tmpLen>maxLen) // 末尾是1的情况 
		{
			start=tmpStart;
			end=n-1;
		}
		printf("%d %d\n",start,end);
	}
	return 0;
}
\end{lstlisting}

\begin{note}[要点]
	合理使用标志变量, 训练自己的逻辑思维能力。
\end{note}

\section{寻找最长的行}	
寻找若干行文本中最长的一行

输入说明	

输入为多个字符串(每个字符串长度不超过100个字符)，每个字符串占一行，输入的行为``***end***"时表示输入结束

输出说明
	
输出其中最长的一行长度后换行再输出最长行的内容，如果最长行不止一个，则输出其中的第一行。

输入样例
	
abce

abdf dlfd

***end***

输出样例
	
9

abdf dlfd 

\begin{lstlisting}
#include <stdio.h>
#include <string.h> // str前缀的字符串处理函数需要此头文件 

// 估计字符串长度，实际容纳(N-1)个有效字符，预留最后一个字符'\0' 
#define N 100

int main()
{
	char lines[N],maxLine[N];
	
	// 在输入的同时，即可处理，不必设置一个一维数组存储这些数。
	while(1)
	{
		gets(lines);  // 不能使用scanf("%s",lines),因其遇空格结束 
		if(strcmp(lines,"***end***") == 0) break;
		if(strlen(lines) > strlen(maxLine)) strcpy(maxLine,lines);
	}
	
	printf("%d\n%s\n",strlen(maxLine),maxLine); 
	
	return 0;
} 
\end{lstlisting}

\begin{note}[要点]
	简单处理即可, 不必用二维字符数组存储各个字符串，否则会导致超时。
\end{note}

\section{统计正整数的个数}
统计n个正整数中每个数出现的次数。

输入说明	

第一行是一个整数n(5<n<30), 表示要待统计整数的个数;

第二行是n个整数，每个整数均小于100000

输出说明
	
按照整数从小到大的顺序依次输出不同的整数及其出现次数, 整数和出现次数之间用冒号$(:)$分隔。

输入样例	

12
 
19 223 35 321 2 33 44 223 2 19 2 19

输出样例

2:3

19:3

33:1

35:1

44:1

223:2

321:1

\begin{lstlisting}
// 思路: 首先排序, 再统计每个数的个数.
#include <stdio.h>
int main()
{
	int n,num[30],i=0;
	scanf("%d",&n);
	while(i < n) 
	{ 
		scanf("%d",&num[i]);
		i++; 
	} 
	
	// 冒泡排序
	int p,q,t;
	for(p = 1; p <= n-1; p++)
	{
		for(q = 0; q < n-p; q++)
		{
			if(num[q] > num[q+1])
			{
				t = num[q];
				num[q] = num[q+1];
				num[q+1] = t;
			}
		}
	} 
	
	// 判断重复数
	int x,num_i = 0;
	x = num[0]; 
	for(i = 0; i < n; i++)
	{
		if(num[i] == x) num_i++;
		else 
		{
			printf("%d:%d\n",x,num_i);
			x = num[i]; // 新数 
			num_i = 1;  // 至少有一个数  
		}	
		
		if (i == n - 1)  // 最后一个数 
		printf("%d:%d\n",x,num_i);
	} 
	
	return 0;
} 
\end{lstlisting}

\begin{note}[要点]
	基本思路: 首先排序, 再统计每个数的个数.
\end{note}

