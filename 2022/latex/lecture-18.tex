\section{指针应用习题课}

\begin{frame}[shrink,fragile]{\small 普通变量作为函数参数(值传递, 形参和实参处于不同存储单元)}
\begin{tikzpicture}
\node[text width=.4\textwidth] (b) {
	\vspace{-0.5cm}
	\begin{lstlisting}
	// 值传递
	void swap(int p1, int p2)
	{
		int tmp;
		tmp=p1;
		p1=p2;
		p2=tmp;
	}
	\end{lstlisting} 
};

\node[anchor=north west,text width=.6\textwidth] (c) at(b.north east) {
	\vspace{-0.5cm}
	\begin{lstlisting}
	int main()
	{
		int a=10, b=20, *pa=&a, *pb=&b;
		if(a<b) swap(a,b); // 值传递,实参不变
		// 注意不是 swap(&a,&b);
		printf("%d,%d,%d,%d\n",a,b,*pa,*pb); 
		// 10,20,10,20
		return 0;
	}
	\end{lstlisting}
};

\draw[dashed,red] (c.north west) -- (c.south west);

\node[anchor=west] (t1) at($(c.south west)+(0.5cm,-0.5cm)$) {\&p1};
\node[anchor=west,rounded corners,draw] (tt1) at(t1.east) {$10\to 20$};
\node[anchor=west] (t2) at($(t1.west)+(0,-0.6)$) {\&p2};
\node[anchor=west,rounded corners,draw] (tt2) at(t2.east) {$20\to 10$};
\node[rounded corners,draw,dashed,red,fit=(t1) (tt2),label=above:swap函数] {};

\node[anchor=west] (m1) at($(tt1.east)+(0.7cm,0)$) {\&a: 63FE14};
\node[anchor=west,rounded corners,draw] (mm1) at(m1.east) {$10$};
\node[anchor=west] (m2) at($(m1.west)+(0,-0.6)$) {\&b: 63FE18};
\node[anchor=west,rounded corners,draw] (mm2) at(m2.east) {$20$};
\node[rounded corners,draw,dashed,red,fit=(m1) (mm2),label=above:main函数] {};

\node[anchor=north west,text width=.4\textwidth,fill=green,rounded corners] at(b.south west) {
	值传递: 形参和实参处于不同存储单元。
	
	函数内对形参的改变, 不会引起实参的改变。
};
\end{tikzpicture}
\end{frame}

\begin{frame}[shrink,fragile]{\small 指针变量作为函数参数(地址传递, 形参和实参指向同一存储单元)}
\begin{tikzpicture}
\node[text width=.4\textwidth] (b) {
\vspace{-0.5cm}
\begin{lstlisting}
// 交换p1,p2指向的内容
// 注意不是交换p1,p2本身
void swap(int *p1, int *p2)
{
	int tmp;
	tmp=*p1;
	*p1=*p2;
	*p2=tmp;
}
\end{lstlisting} 
};

\node[anchor=north west,text width=.6\textwidth] (c) at(b.north east) {
\vspace{-0.5cm}
\begin{lstlisting}
int main()
{
  int a=10, b=20, *pa=&a, *pb=&b;
  if(a<b) swap(pa,pb); //地址传递
  //if(a<b) swap(&a,&b); //等效, 地址传递
  printf("%d,%d,%d,%d\n",a,b,*pa,*pb); 
  // 20,10,20,10
  return 0;
}
\end{lstlisting}
};

\draw[dashed,red] (c.north west) -- (c.south west);

\node[anchor=west] (t1) at($(c.south west)+(0.5cm,-0.5cm)$) {p1};
\node[anchor=west,rounded corners,draw] (tt1) at(t1.east) {63FE14};
\node[anchor=west] (t2) at($(t1.west)+(0,-0.6)$) {p2};
\node[anchor=west,rounded corners,draw] (tt2) at(t2.east) {63FE18};
\node[rounded corners,draw,dashed,red,fit=(t1) (tt2),label=above:swap函数] {};

\node[anchor=west] (m1) at($(tt1.east)+(0.7cm,0)$) {\&a: 63FE14};
\node[anchor=west,rounded corners,draw] (mm1) at(m1.east) {$10\to 20$};
\node[anchor=west] (m2) at($(m1.west)+(0,-0.6)$) {\&b: 63FE18};
\node[anchor=west,rounded corners,draw] (mm2) at(m2.east) {$20\to 10$};
\node[rounded corners,draw,dashed,red,fit=(m1) (mm2),label=50:main函数] {};

\path[->,dashed,blue]
(tt1) edge[bend left] node[anchor=south]{*p1} (mm1)
(tt2) edge[bend right] node[anchor=north]{*p2} (mm2)
;

\node[anchor=north west,text width=.4\textwidth,fill=green,rounded corners] at(b.south west) {
	地址传递就是函数间共享内存。
	
	形参实参地址相同。
	
	函数内对指针目标变量的改变, 就是改变实参的内容。
};
\end{tikzpicture}
\end{frame}

\begin{frame}[shrink,fragile]{常见错误}
\begin{columns}[T]
\column{0.5\textwidth}
\begin{lstlisting}
//对p1,p2值交换而不是交换p1,p2指向的内容 
//p1,p2是局部变量,不会引起实参值的改变
void swap(int *p1, int *p2)
{
  int *tmp;
  tmp=p1;
  p1=p2;
  p2=tmp;
}
\end{lstlisting}
\column{0.5\textwidth}
\begin{lstlisting}[frame=leftline]
// tmp使用前，要有指向
void swap(int *p1, int *p2)
{
  int *tmp;//没有指向, 即未赋值
  *tmp=*p1;//错! tmp没有指向就间接访问
  *p1=*p2;
  *p2=*tmp;
}
\end{lstlisting}
\end{columns}
\medskip
\end{frame}

\begin{frame}[shrink,fragile]{例: 选择法排序字符串数组}
\begin{tikzpicture}
\node[text width=.55\textwidth] (a) {
\vspace{-0.5cm}
\begin{lstlisting}
#define N 100 // 估计最大字符串个数
void sort(char name[][81],int n);
int main()
{
  char name[N][81]; // N个字符串
  int n=10,i; // n是实际字符串个数

  for(i=0;i<n;i++) // 输入n个字符串
  {
    gets(name[i]); 
  }
  sort(name,n); // 排序
  for(i=0;i<n;i++) // 输出
  {
    puts(name[i]); 
  }
}
\end{lstlisting}
};

\node[anchor=north west,text width=.55\textwidth] (b) at(a.north east) {
\vspace{-0.5cm}
\begin{lstlisting}
// 用选择法排序(从小到大)
void sort(char name[][81],int n)
{
  char tmp[81];
  int i,j,k;
  for(i=0;i<n-1;i++)
  {
    k=i;// 未排序部分最小的字符串
    for(j=i+1;j<n;j++)
      if(strcmp(name[k],name[j])>0) k=j;
    if(k!=i) // 交换字符串
    {
       strcpy(tmp,name[i]); 
       strcpy(name[i],name[k]); 
       strcpy(name[k],tmp);
    }
  }
}
\end{lstlisting}
};

\draw[red,dashed] (b.north west) -- (b.south west);
\end{tikzpicture}
\end{frame}

\begin{frame}[shrink,fragile]{\small 例: 输入二进制字符串, 求其表示的整数值. 按字符接收}
e.g., 输入: 10101, 输出: 21; \quad 输入101, 输出:  5
\begin{lstlisting}
#include<stdio.h>
int main()
{
	char ch;
	int sum=0;
	while(1)
	{
		ch=getchar(); //或 scanf("%c",&ch);
		if(ch!='0' && ch !='1') break; // 遇非0,1字符结束
		// if(ch=='\n') break; // 遇回车结束, 等效
		sum=sum*2+ch-'0'; 
	} 
	printf("%d\n",sum);
	return 0;
}
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{\small 例: 输入二进制字符串, 求其表示的整数值, 字符串数组与指针操作}
\begin{center}
\begin{tikzpicture}
\node[text width=.45\textwidth,rounded corners,draw] (a) {
\begin{lstlisting}
// 数组操作
#define N 31
char ch[N];
int sum=0,i;
gets(ch);  // 末尾自动追加'\0'
for(i=0;ch[i]!='\0';i++)
{
	sum=sum*2+ch[i]-'0';
	// for的第3个表达式移动数组下标
} 
printf("%d\n",sum);
\end{lstlisting}
};

\node[anchor=north west,text width=.45\textwidth,rounded corners,draw] (b) at(a.north east) {
	\begin{lstlisting}
	// 指针操作
	#define N 31
	char ch[N], *p=ch;
	int sum=0;
	gets(ch); // 末尾自动追加'\0'
	while((*p)!='\0')
	{
		sum=sum*2+ (*p - '0');
		p++; // 指向下一个字符
	} 
	printf("%d\n",sum);
	\end{lstlisting}
};
\end{tikzpicture}
\end{center}
\end{frame}

\begin{frame}[shrink,fragile]{例: 表达式求值}
\vspace{-0.2cm}
表达式由两个\textcolor{blue}{非负整数x，y}和一个运算符op构成，求表达式的值。\\
这两个整数和运算符的顺序是随机的，可能是\textcolor{blue}{``x op y", ``op x y"或者``x y op"}, 例如，``25 + 3"表示25加3，``5 30 *" 表示5乘以30, ``/ 600 15"表示600除以15。\\
输入说明：输入为一个表达式, 表达式由两个非负整数x, y和一个运算符op构成, x,y和op之间以空格分隔, 但顺序不确定。
x和y均不大于10000000, op可以是+, -, *, /, \%中的任意一种，分表表示加法，减法，乘法，除法和求余。
除法按整数除法求值，输入数据保证除法和求余运算的y值不为0。\\
输出说明：输出表达式的值。\\
\medskip
\begin{columns}
	\column{0.3\textwidth}
	样例1输入 5 20 *\\
	样例2输入 4 + 8\\
	样例3输入 / 8 4
	\column{0.3\textwidth}
	样例1输出 100\\ 
	样例2输出 12\\
	样例3输出 2
\end{columns}
\medskip
\end{frame}

\begin{frame}[shrink,fragile]{例: 表达式求值---解题思路}
\vspace{-0.5cm}
\begin{itemize}
	\item \lstinline|gets|函数读取字符串，遍历字符串，根据op字符是"非数字字符"的特点，判断表达式的三种形式。\\
	\item 设计各个子函数, 进行模块化程序设计。
	\item 编写函数parse, 解析输入字符串, 生成3个子串, 分别代表op,x,y
	\item 编写函数strToInt, 将数字字符串转为整数。
	\item 编写函数compute, 根据op,x,y计算表达式的值。
	\item 编写其它辅助函数。
	\item 主函数, 调用上述函数, 完成程序功能。
\end{itemize}
\textbf{\textcolor{blue}{注:}}\\
	 \lstinline|char s1[81],s2[81],s3[81]; scanf("%s%s%s",s1,s2,s3);// 遇空格结束特点(忽略前缀后缀空格), 自动获取3个子串, 无需分解。|
\end{frame}

\begin{frame}[shrink,fragile]{例: 表达式求值---计算函数}
\begin{lstlisting}
// 根据参数，计算表达式的值 
int compute(char op,int x,int y)
{
   int result = -1;
   switch(op)
   {
     case '+': result = x+y; break;
     case '-': result = x-y; break;
     case '*': result = x*y; break;
     case '/': if(y != 0) result = x/y; break;
     case '%': if(y != 0) result = x%y; break;
   }
   return result;
}
\end{lstlisting}
\end{frame}

\begin{frame}[shrink,fragile]{例: 表达式求值---将数字字符串转为整数函数}
\begin{lstlisting}
// 数字字符串s转为int, 要求s以'\0'结尾 
int strToInt(char *s) //等效: int toInt(char s[]) 
{
  int result=0;
  while(*s) //等效 *s != '\0'
  {
     result = result*10 + (*s-'0'); // 数字位整数=字符-'0'
     s++; //移至下一字符 
  }
  return result;
} 
\end{lstlisting}
\textcolor{blue}{注: 简单修改此函数, 可将由01组成的二进制字符串转为整数。}
\end{frame}

\begin{frame}[shrink,fragile]{例: 表达式求值---提取子串函数}
\begin{tikzpicture}
\node[text width=.7\textwidth] (a) {
\vspace{-0.5cm}
\begin{lstlisting}
char* getSubs(char *s, char *subs) 
{
  int start=0; // 是否开始提取标志
  while(*s) // 等效 *s!='\0'
  {
    if(*s==' ') 
    {
      if(start==0) s++; // 未开始复制, 忽略s的前缀空格 
      else break; // 是有效字符串后的一个空格 
    }
    else
    {
      start=1; // 标记开始复制 
      *subs=*s;  s++;  subs++;
    }
  }
  *subs='\0'; // 不要忘记结尾符 
  return s; // 返回复制后s指针当前指向(地址)
}
\end{lstlisting}
};

\node[anchor=north west,text width=.55\textwidth,rounded corners,draw] at($(a.north east) + (0,-1cm)$) {
	提取子串函数, 忽略s中空格前缀，复制s中的字符串到subs中，遇空格或\lstinline|'\0'|结束。
	
    返回参数subs不含空格。
    
    函数返回复制后s指针当前指向(地址)。 
	
	要求s和subs以\lstinline|'\0'|结尾。
	
	注: 简单修改此函数, 可以任何分隔符提取子串函数
};
\end{tikzpicture}
\end{frame}

\begin{frame}[shrink,fragile]{例: 表达式求值---解析字符串函数}
\begin{lstlisting}
// 解析s, 以空格为分隔符, 分解s为3个字符串, 通过参数result返回
void parse(char *s,char result[][N])
{
  char *p;
  p=getSubs(s,result[0]);
  p=getSubs(p,result[1]);
  getSubs(p,result[2]);
} 
\end{lstlisting}
\textcolor{blue}{注: 通过此函数, 学习字符串数组的使用技巧。}
\end{frame}

\begin{frame}[shrink,fragile]{例: 表达式求值---是否运算符函数}
\begin{lstlisting}
// 如果s是操作符，返回1, 参数op返回该操作符
// 否则, 返回0 
int isOp(char *s, char *op)
{
  if(*s >= '0' && *s <= '9') 
    return 0;
  else
  {
    *op=*s;
    return 1;
  }
} 
\end{lstlisting}
\textcolor{blue}{注: 通过此函数, 学习地址传递技巧。}
\end{frame}

\begin{frame}[shrink,fragile]{例: 表达式求值---测试主函数}
\vspace{-0.3cm}
\begin{lstlisting}
int main1() // 测试主函数, 使能改为main(), 原main()改名
{
   char *s="123";
   printf("%d\n",strToInt(s)); // 123
   char s1[N]="    abcd   456  +", s2[50], *s3;
   s3= getSubs(s1,s2);
   printf("%s,%d\n",s2,*s3); // abcd,32(空格的ASCII码) 
   s3= getSubs(s3,s2);
   printf("%s,%d\n",s2,*s3); // 456,32(空格的ASCII码) 
   s3= getSubs(s3,s2);  
   printf("%s,%d\n",s2,*s3); // +,0('\0'的ASCII码)
   char result[3][N];
   parse(s1,result);
   puts(result[0]); // abcd
   puts(result[1]); // 456
   puts(result[2]); // +
   return 0;
}
\end{lstlisting}
\end{frame}

\begin{frame}[shrink,fragile]{例: 表达式求值---主程序}
\vspace{-0.3cm}
\begin{lstlisting}
#include <stdio.h>
// 自定义函数在调用之前定义，略去函数声明。 
#define N 81 // 估计字符串最大长度，存储有效字符(N-1)个，预留最后一个字符'\0'
int main()
{
  char s[N], op, char s3[3][N];   
  int x,y;
  gets(s); // 不能使用scanf("%s",s); 空格将会终止
  parse(s,s3); // s被分解为3个字符串 
  if(isOp(s3[0],&op)) // op x y
  { x=strToInt(s3[1]);  y=strToInt(s3[2]); }
  else if(isOp(s3[1],&op)) // x op y
  { x=strToInt(s3[0]); y=strToInt(s3[2]); }
  else if(isOp(s3[2],&op)) // x y op
  { x=strToInt(s3[0]); y=strToInt(s3[1]); }
  printf("%d\n",compute(op,x,y)); 
  return 0;
}
\end{lstlisting}
\end{frame}

\begin{frame}[shrink,fragile]{例: 表达式求值---主程序(另解, 直接获取3个字符串)}
\vspace{-0.3cm}
\begin{lstlisting}
#include <stdio.h>
// 自定义函数在调用之前定义，略去函数声明。
#define N 81 // 估计字符串最大长度，存储有效字符(N-1)个，预留最后一个字符'\0' 
int main()
{
  char s[N], op, char s3[3][N];   
  int x,y;
  // 利用"%s"读字符串遇空格结束特点，直接读取3个字符串。
  scanf("%s%s%s",s3[0],s3[1],s3[2]);
  if(isOp(s3[0],&op)) // op x y
  { x=strToInt(s3[1]);  y=strToInt(s3[2]); }
  else if(isOp(s3[1],&op)) // x op y
  { x=strToInt(s3[0]); y=strToInt(s3[2]); }
  else if(isOp(s3[2],&op)) // x y op
  { x=strToInt(s3[0]); y=strToInt(s3[1]); }
  printf("%d\n",compute(op,x,y)); 
  return 0;
}
\end{lstlisting}
\end{frame}

\begin{frame}{复习指引}
\vspace{-0.2cm}
\begin{columns}
	\column{0.7\linewidth}
	\begin{itemize}
		\item 认真复习ppt及百道练习题，确保不犯低级错误。
		\item 认真复习ppt及百道练习题，深刻体会编程思路。
		\item 认真复习ppt及百道练习题，注重一题多解，总结自己的编程宝典，做到遇类似问题，脑洞大开。
		\item 善用标志变量(如, 跳一跳, 字符计数，连续1等练习题)，标志矩阵(如, 消费类游戏, 购票系统等练习题)。
		\item 善用函数，简化程序设计。
		\item 应用结构体和函数得到逻辑简单, 思路清晰的程序。貌似复杂的问题迎刃而解。 
	\end{itemize}
	\column{0.3\linewidth}
	\centering\includegraphics[scale=0.2]{timg}
\end{columns}
\end{frame}

