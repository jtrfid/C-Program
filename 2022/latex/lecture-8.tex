%%%%%%%%%%%%%%%%%%%%%%%%%% lecture-9
%\begin{frame}[shrink]
%  \frametitle{lecture-9 主要内容}
%  \framesubtitle{循环结构程序设计举例(续)}
%  \tableofcontents[hideallsubsections]
%\end{frame}

\section{循环结构程序设计举例(续)}

\begin{frame}[fragile]
附加题1: 求$s=a+aa+aaa+\cdots+a\cdots a$, 其中$a$是一个$1\sim 9$的数字。例如$a=2, n=4$时, $s=2+22+222+2222$, $a$和$n$由键盘输入。
\pause
\begin{columns}
\column{0.9\textwidth}
\begin{lstlisting}
int i,s,n,term = 0;
for(i=1,s=0; i<=n; i++) // 初始化循环变量用逗号隔开
{
   term = term*10 + a;
   s += term; 
}
\end{lstlisting}
\end{columns}
\end{frame}

\begin{frame}[fragile]
\small
附加题2: 韩信点兵。韩信有一队兵, 他想知道有多少人, 便让士兵排队报数:\\
按从1至5报数, 最末一个士兵报的数为1;\\
按从1至6报数, 最末一个士兵报的数为5;\\
按从1至7报数, 最末一个士兵报的数为4;\\
按从1至11报数,最末一个士兵报的数为10;\\ 
计算韩信至少有多少兵。 
\pause
\begin{columns}
\column{0.8\textwidth}
\begin{lstlisting}
int x=1;
for(;;x++)  // 循环体仅含if()结构，看作一条语句，'{}'可省略
    if(x%5==1 && x%6==5 && x%7==4 && x%11==10)
    { 
       printf("%d\n",x);  
       break;
    }
\end{lstlisting}
\end{columns}
\end{frame}

\begin{frame}[fragile]
附加题3-1: 求水仙花数。如果一个三位数的个位数、十位数和百位数的立方和等于该数自身，则称该数为水仙花数。 \\
编程求出所有的水仙花数。\\
~\\  
\pause
\begin{columns}
\column{0.6\textwidth}
解法一: 采用三重循环
\begin{lstlisting}
int i,j,k; // 百、十、个位
for(i=1;i<=9;i++)    // 百位
  for(j=0;j<=9;j++)  // 十位
    for(k=0;k<=9;k++)  // 个位
      if(i*100+j*10+k == i*i*i+j*j*j+k*k*k)  
        printf("%d\n",i*100+j*10+k);
\end{lstlisting}
\end{columns}
\end{frame}

\begin{frame}[fragile]
附加题3-2: 求水仙花数。如果一个三位数的个位数、十位数和百位数的立方和等于该数自身，则称该数为水仙花数。 \\
编程求出所有的水仙花数。\\
~\\ 
\pause
\begin{columns}
\column{0.6\textwidth}
解法二: 采用一重循环
\begin{lstlisting}
int m,i,j,k; 
for(m=100;m<=999;m++)
{
   i=m/100; j=m/10%10; k=m%10;  
   if(i*100+j*10+k == i*i*i+j*j*j+k*k*k)  
      printf("%d\n",i*100+j*10+k);
}
\end{lstlisting}
\end{columns}
~\\
\textcolor{blue}{思考: 输出共有多少个水仙数?}
\end{frame}

\begin{frame}[fragile]
附加题3-3: 求整数区间$[a,b]$中水仙花数的个数。
\pause
\vspace{-0.2cm}
\begin{columns}
\column{1.0\textwidth}
\begin{lstlisting}
int n=0; //计数 
int a,b; // a,b 区间
int i,t;   // 循环变量，代表a,b区间的每个数
int sum; // i的各位立方和 
scanf("%d%d",&a,&b);
for(i=a;i<=b;i++) // 考察i是否水仙数
{  
  sum = 0; t=i; // 临时变量记住i; 易遗漏每次内层循环前sum要归0
  while(t!=0) // 累加各位立方 
  { sum=sum+(t%10)*(t%10)*(t%10);   // 不好: sum+=pow(t%10,3);
     t=t/10; 
  }
  if(sum==i) n++; // i是水仙数 
}
printf("%d\n",n);
\end{lstlisting}
\end{columns}
\end{frame}

\begin{frame}[fragile]
附加题4: 百钱百鸡, 已知公鸡5个钱1只, 母鸡3个钱1只, 小鸡1个钱3只, 用100个钱买了100只鸡。问公鸡、母鸡、小鸡各几只? 
\vspace{0.5cm}
\pause
\begin{columns}
%\column{0.9\textwidth}
\begin{lstlisting}
int x,y,z; // 公鸡、母鸡、小鸡个数
for(x=0;x<=100;x++) 
   for(y=0;y<=100;y++) 
     for(z=0;z<=100;z++) 
       if(5*x+3*y+z/3 == 100 && x+y+z == 100 && z%3 == 0) //全部条件 
          printf("%d,%d,%d\n",x,y,z);
\end{lstlisting}
\end{columns}
\vspace{0.5cm}
\textcolor{blue}{如何考虑无解的情况?}
\end{frame}

\begin{frame}[shrink,fragile,plain]
附加题5-1: 求整数$a,b$的最大公约数，当两个数中有一个为0时，公约数是不为0的那个整数; 当两个整数互质时最大公约数为1。
输入两个整数a和b，求最大公约数。 
\pause
\begin{lstlisting}
int main() // 暴力循环求解, 效率低
{
	int a,b,t=-1,i; // t给初值是好习惯，否则下面程序逻辑有可能使t得到随机值。 
	scanf("%d%d",&a,&b); // 机试系统不要想当然给提示语句, 除非题目要求  
	if(a<b) { t=a; a=b; b=t; } // 交换a,b,使a是较大者 
	if(b==0) t=a; // 考虑分母为0的情况，比如：5,0的最大公约数为5 
	else
	{
		for(i=b;i>0;i--)
		{
			if(a%i==0 && b%i==0) 
			{ t=i; break; } // 求得最大公约数，a,b互质, 必然t=1 
		}
	}
	printf("%d\n",t);
	return 0;	
}
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{求整数$a,b$的最大公约数, 欧几里得算法}
\vspace{-0.3cm}
\begin{tikzpicture}[font=\small]
\node[align=left,text width=0.85\textwidth] (left) {古希腊数学家欧几里德在其著作<<The Elements>>中最早描述了这种算法。\\
	\textbf{定理：}两个整数的最大公约数等于其中较小的那个数和两数相除余数的最大公约数。};
\node[right] at(left.east) {\includegraphics[scale=0.25]{eou}};
\end{tikzpicture}

令$a=bq+r, q=\lfloor\frac{a}{b}\rfloor,r=a\%b$, 设$a,b$的公约数$u,(a=su, b=tu)$, 我们有

$r=a-bq=su-qtu=(s-qt)u$, 表明$a,b$的公约数$u$也整除$r$. 

类似的, 设$b$和$r$的公约数$v,(b=s'v, r=t'v$), 则

$a=bq+r=s'vq+t'v=(s'q+t')v$, 表明$b$和$r$的公约数$v$也整除$a$.

\medskip
\textcolor{blue}{(1) 如果$r=a\%b=0$, 最大公约数为$b$. (2) 如果$r\ne 0$, 令$a=b,b=r$, 返回到(1).}

\textcolor{blue}{重复迭代(1),(2)步, 直至余数为0, 即求得最大公约数.}

\small\textcolor{red}{注: $\lfloor\frac{a}{b}\rfloor$表示$\frac{a}{b}$的结果向下取整, 在C语言中, $a/b=\lfloor\frac{a}{b}\rfloor$}
\end{frame}

\begin{frame}{欧几里得算法 --- 求整数$a,b$最大公约数: 迭代过程}
%Therefore, every common divisor of $a$ and $b$ is a common divisor of $b$ and $r$, so the procedure can be iterated as follows:
\vspace{-1cm}
\begin{align*}
q_1&=\lfloor\frac{a}{b}\rfloor		& a&=bq_1+r_1    	& r_1&=a-bq_1\\
q_2&=\lfloor\frac{b}{r_1}\rfloor 	& b&=q_2r_1+r_2  	& r_2&=b-q_2r_1\\
q_3&=\lfloor\frac{r_1}{r_2}\rfloor 	& r_1&=q_3r_2+r_3  	& r_3&=r_1-q_3r_2\\
q_4&=\lfloor\frac{r_2}{r_3}\rfloor 	& r_2&=q_4r_3+r_4  	& r_4&=r_2-q_4r_3\\
\cdots\\
q_n&=\lfloor\frac{r_{n-2}}{r_{n-1}}\rfloor 	& r_{n-2}&=q_4r_{n-1}+r_n  	& r_n&=r_{n-2}-q_nr_{n-1}\\
q_{n+1}&=\lfloor\frac{r_{n-1}}{r_{n}}\rfloor 	& r_{n-1}&=q_{n+1}r_{n}+0  	& r_n&=r_{n-1}/q_{n+1} 
\end{align*}

迭代至$q_{n+1}, r_{n-1}\%r_n=0$, 得到$a,b$的最大公约数: $r_n=r_{n-1}/q_{n+1}$. 就是余数为0时的分母值.
%For integers, the algorithm terminates when $q_{n+1}$ divides $r_{n-1}$ exactly, at which point $r_n$ corresponds to the greatest common divisor of $a$ and $b,~\text{GCD}(a,b)=r_n$. 
\end{frame}

\begin{frame}{欧几里得算法 --- 求整数$a,b$最大公约数: 迭代过程(例)}

\begin{tikzpicture}
\node[text width=.48\textwidth] (left) {
	$a=42,b=30$
	\begin{align*}
	q_1&=\lfloor\frac{a}{b}\rfloor=\lfloor\frac{42}{30}\rfloor=1	& r_1&=12\\
	q_2&=\lfloor\frac{b}{r_1}\rfloor=\lfloor\frac{30}{12}\rfloor=1 	& r_2&=6\\
	q_3&=\lfloor\frac{r_1}{r_2}\rfloor\lfloor\frac{12}{6}\rfloor=2 	& r_3&=0
	\end{align*}
	Greatest Common Divisor of $(42,30)$ is
	
	$r_2=6$
};
\node[right,text width=.5\textwidth] (r) at(left.east) {
	$a=144,b=55$ 
	\begin{align*}
	r_1&=a\%b=34     & r_2&=b\%r_1=21\\
	r_3&=r_1\%r_2=13 & r_4&=r_2\%r_3=8\\
	r_5&=r_3\%r_4=5  & r_6&=r_4\%r_5=3\\
	r_7&=r_5\%r_6=2  & r_8&=r_6\%r_7=1\\
	r_9&=r_7\%r_8=0
	\end{align*}
	Greatest Common Divisor of $(144,55)$ is
	
	$r_8=1$	
};
\draw[red,thick] (r.north west) -- (r.south west);
\end{tikzpicture}
 
\end{frame}

\begin{frame}[fragile]{欧几里得算法 --- 求整数$a,b$的最大公约数: 伪代码}
\textbf{定理：}两个整数的最大公约数等于其中较小的那个数和两数相除余数的最大公约数。

\medskip
\begin{lstlisting}
a(大),b(小)的最大公约数: 因为: a=qb+r, q=a/b; r=a%b, $\Rightarrow$a,b的公约数能整除b和r.
r=a%b,r为0, 则b就是最大公约数。否则迭代循环, a=b，b=r, 直到余数为零, 则分母就是最大公约数。 
while(1)
{
   if(b==0) { gcd=a; break; } // 分母(上轮计算的余数)为0时, a就是最大公约数
   r = a%b; // 注意b为0时，不能计算余数，a就是最大公约数
   if(r==0) { gcd=a; break; } // 本轮循环的a(上轮循环的b)就是最大公约数
   a=b; b=r; // 准备下一轮迭代    
}
\end{lstlisting}
\end{frame}

\begin{frame}[shrink,fragile]{求整数$a,b$的最大公约数, 欧几里得算法, 参考代码(1)}
\begin{lstlisting}
int a,b,r,t;
scanf("%d%d",&a,&b); // 机试系统不要想当然给提示语句, 除非题目要求
if(a<b) { t=a; a=b; b=t; } // 交换a,b,使a是较大者
while(1)
{
   if(b==0) { t=a; break; } // 分母(上轮计算的余数)为0时, a就是最大公约数
   r = a%b; 
   if(r==0) {t=b; break;} // b就是最大公约数
   a=b; b=r; // 准备下一轮迭代   
}
printf("%d\n",t);// 输出最大公约数
\end{lstlisting}
\end{frame}

\begin{frame}[shrink,fragile]{求整数$a,b$的最大公约数, 欧几里得算法, 参考代码(2)}
\begin{lstlisting}
int main()
{
	int a,b,r,t;
	scanf("%d%d",&a,&b); // 机试系统不要想当然给提示语句, 除非题目要求
	if(a<b) { t=a; a=b; b=t; } // 交换a,b,使a是较大者
	if (b==0) // 考虑分母为0的情况，比如：5,0的最大公约数为5 
	{
		printf("%d\n",a);
		return 0; // 主函数结束
	}
	while((r=a%b)!=0) // 去除了分母为0的情况
	{
		a=b; b=r; // 准备下一轮迭代   
	}
	printf("%d\n",b);
	return 0; // 主函数结束
}	
\end{lstlisting}
\end{frame}

\begin{frame}[shrink,fragile]{求整数$a,b$的最大公约数, 欧几里得算法, 参考代码(3)}
\begin{lstlisting}
int main()
{
	int a,b,r,t;
	scanf("%d%d",&a,&b); // 机试系统不要想当然给提示语句, 除非题目要求
	if(a<b) { t=a; a=b; b=t; } // 交换a,b,使a是较大者
	if (b==0) // 考虑分母为0的情况，比如：5,0的最大公约数为5 
	{
		printf("%d\n",a);
	}
	else
	{
		// 排除了分母为0时不能求余数的情况 
		while((r=a%b)!=0) // a/b的余数赋值给r,r不等于0时执行循环体
		{	a=b; b=r; }
		printf("%d\n",b);
	}
	return 0; // 主函数结束
}	
\end{lstlisting}
\end{frame}

\begin{frame}{注意事项小结}
\begin{enumerate}
\setlength{\itemsep}{.5cm}
\item while( )\{ \}; do \{ \} while( ); for(;;)\{ \}执行顺序；
\item 循环变量的开始和结束条件；
\item 循环体是复合语句时，必须用\{ \}扩起来；
\item 必要时，用break结束整个循环，用continue结束本次循环；
\item 关键是找出循环规律，必要时设计流程图，指导代码实现。	
\end{enumerate}
\end{frame}